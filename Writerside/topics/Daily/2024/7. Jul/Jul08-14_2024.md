# July 2024, Week 2: July 8th - July 14th

## July 8 -> 1823. Find the Winner of the Circular Game {collapsible="true" default-state="collapsed"}

There are `n` friends that are playing a game.
The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**.
More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend
for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend.

The rules of the game are as follows:

1. **Start** at the `1st` friend.
2. Count the next `k` friends in the clockwise direction **including** the friend you started at.
   The counting wraps around the circle and may count some friends more than once.
3. The last friend you counted leaves the circle and loses the game.
4. If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately
   clockwise** of the friend who just lost and repeat.
5. Else, the last friend in the circle wins the game.

Given the number of friends, `n`, and an integer `k`, return *the winner of the game*.

**Example 1:**

![july08-2024-ex1.png](july08-2024-ex1.png)

- **Input:** n = 5, k = 2
- **Output:** 3
- **Explanation:** Here are the steps of the game:
    1. Start at friend 1.
    2. Count two friends clockwise, which are friends 1 and 2.
    3. Friend 2 leaves the circle. Next start is friend 3.
    4. Count two friends clockwise, which are friends 3 and 4.
    5. Friend 4 leaves the circle. Next start is friend 5.
    6. Count two friends clockwise, which are friends 5 and 1.
    7. Friend 1 leaves the circle. Next start is friend 3.
    8. Count two friends clockwise, which are friends 3 and 5.
    9. Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.

**Example 2:**

- **Input:** n = 6, k = 5
- **Output:** 1
- **Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.

**Constraints:**

- `1 <= k <= n <= 500`

---

### Approach 1: Simulation with Deque {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def findTheWinner1(n: int, k: int) -> int:
    """
    Determines the winner of a circular elimination game among `n` players.

    This function simulates the game using a deque (double-ended queue) to
    represent the circle of players. It efficiently rotates the deque to move
    players and eliminates them until only one player remains. The deque
    allows for O(1) operations at both ends, which is crucial for the
    efficient simulation of the circular nature of the game.

    The time complexity of this solution is O(n * k), where `n` is the number
    of players and `k` is the counting interval. This is because for each
    elimination (which happens n-1 times), we perform k rotations of the
    deque. The space complexity is O(n) as we store all `n` players in the deque
    initially.
    """
    active_players = deque(range(n))
    while len(active_players) > 1:
        # Move k-1 players to the end of the queue
        for _ in range(k - 1):
            active_players.append(active_players.popleft())
        # Remove the k-th player
        active_players.popleft()
    # Convert to 1-based indexing for the result
    return active_players[0] + 1
```

{collapsible="true" default-state="expanded" collapsed-title="Simulation with Deque Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a deque (double-ended queue) to simulate the circular elimination
game efficiently.
This approach directly models the game's mechanics by rotating players and removing them as per the
rules.

- **Circular Nature Simulation:** The deque allows for efficient rotation of players, mimicking the circular arrangement
  described in the problem.
- **Player Elimination:** By using the deque's `popleft()` method, we can easily remove players from the game when they
  are counted out.
- **Efficient Rotation:** The deque's ability to perform $O(1)$ operations at both ends makes it ideal for simulating the
  counting process without the need for complex index calculations.

> **Key Insight:**
> The use of a deque allows us to avoid the overhead of managing circular indexing manually.
> By moving players from the front to the back of the deque, we naturally simulate the circular counting process.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   active_players = deque(range(n))
   ```
   We create a deque containing integers from 0 to `n-1`, representing the players.
   Using 0-based indexing simplifies the simulation process.

2. **Game Simulation Loop:**
   ```python
   while len(active_players) > 1:
   ```
   This loop continues until only one player remains, simulating the entire game process.

3. **Player Rotation:**
   ```python
   for _ in range(k - 1):
       active_players.append(active_players.popleft())
   ```
   We rotate `k-1` players from the front to the back of the deque.
   This simulates the counting process without actually removing any players yet.
   We use `k-1` because the `k`th player will be removed in the next step.

4. **Player Elimination:**
   ```python
   active_players.popleft()
   ```
   After the rotation, the player at the front of the deque is the `k`th player in the count.
   We remove this player using `popleft()`, simulating their elimination from the game.

5. **Result Calculation/Return:**
   ```python
   return active_players[0] + 1
   ```
   Once the loop ends, only one player remains in the deque.
   We return this player's number, adding 1 to convert from 0-based to 1-based indexing as required by the
   problem statement.

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n * k)$, where $n$ is the number of players and $k$ is the counting interval.
  This is because we perform $n-1$ eliminations (as we start with $n$ players and end with 1),
  and for each elimination, we rotate the deque $k$ times.

**Space Complexity:**

- $O(n)$, where $n$ is the number of players.
  This is because we store all $n$ players in the deque initially.
  The space used remains constant throughout the execution of the algorithm, even as players are eliminated.

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

**Input:**

```python
n = 6
k = 5
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - Create a `deque` called `active_players` with values `[0, 1, 2, 3, 4, 5]`, representing the players in 0-indexed
      form.

2. **Main Loop (Elimination Process):**

    - **Iteration 1:**
        - Current active players: `[0, 1, 2, 3, 4, 5]`
        - We need to remove the fifth player (k=5)
        - Rotate the deque 4 times (k-1):
            - Move 0 to the end: `[1, 2, 3, 4, 5, 0]`
            - Move 1 to the end: `[2, 3, 4, 5, 0, 1]`
            - Move 2 to the end: `[3, 4, 5, 0, 1, 2]`
            - Move 3 to the end: `[4, 5, 0, 1, 2, 3]`
        - Remove the front player (4)
        - Resulting deque: `[5, 0, 1, 2, 3]`

    - **Iteration 2:**
        - Current active players: `[5, 0, 1, 2, 3]`
        - Rotate 4 times:
            - Final state after rotation: `[3, 5, 0, 1, 2]`
        - Remove the front player (3)
        - Resulting deque: `[5, 0, 1, 2]`

    - **Iteration 3:**
        - Current active players: `[5, 0, 1, 2]`
        - Rotate 4 times:
            - Final state after rotation: `[5, 0, 1, 2]`
        - Remove the front player (5)
        - Resulting deque: `[0, 1, 2]`

    - **Iteration 4:**
        - Current active players: `[0, 1, 2]`
        - Rotate 4 times:
            - Final state after rotation: `[1, 2, 0]`
        - Remove the front player (1)
        - Resulting deque: `[2, 0]`

    - **Iteration 5:**
        - Current active players: `[2, 0]`
        - Rotate 4 times:
            - Final state after rotation: `[2, 0]`
        - Remove the front player (2)
        - Resulting deque: `[0]`

3. **Loop Termination:**
    - The loop terminates when only one player remains in the `active_players` deque.
    - Final state of `active_players`: `[0]`

4. **Visual Aids:**

   The following image represents the simulation process for the example input `n = 6, k = 5` where the red elements 
   represent the players that will be removed in each round.
   The visualization shows the rotation of the deque and the elimination of players until only one player remains.

   ![july08-2024-ap1-visualization.png](july08-2024-ap1-visualization.png)

   Iteration Summary:

   | Round | Active Players  | Removed Player |
   |-------|-----------------|----------------|
   | 1     | [5, 0, 1, 2, 3] | 4              |
   | 2     | [5, 0, 1, 2]    | 3              |
   | 3     | [0, 1, 2]       | 5              |
   | 4     | [2, 0]          | 1              |
   | 5     | [0]             | 2              |

5. **Result Calculation/Final Steps:**
    - The last remaining player in `active_players` is 0 (0-indexed).
    - Convert to 1-indexed by adding 1: 0 + 1 = 1
    - Return 1 as the final result.

The winner of the game is player 1 (in 1-indexed form).

---

### Approach 2: Recursive Josephus Problem Solution {id="approach_d1_2" collapsible="true" default-state="expanded"}

```Python
def findTheWinner2(n: int, k: int) -> int:
    """
    Determines the winner of a circular elimination game among `n` players.

    This function employs a recursive approach to solve the Josephus problem.
    Instead of simulating the game directly, it calculates the position of
    the survivor based on  mathematical relationships between game states
    with n and n-1 players. This method leverages the recursive nature of the
    problem to efficiently compute the winner's position.

    The time complexity of this solution is O(n), where `n` is the number of
    players. This is because the function makes `n` recursive calls, each
    doing constant time operations. The space complexity is O(n) due to the
    recursion stack, which can go `n` levels deep.
    """
    def simulate_game(players: int, step: int) -> int:
        """
        Helper function to recursively simulate the game and find the
        survivor's position.
        """
        # Base case: if only one player remains, they are at position 0
        if players == 1:
            return 0

        # Recursive case: calculate the survivor's position
        # for n-1 players and adjust it for n players
        survivor_position = simulate_game(players - 1, step)
        return (survivor_position + step) % players

    # Convert the result to 1-based indexing
    return simulate_game(n, k) + 1
```

{collapsible="true" default-state="expanded" collapsed-title="Recursive Josephus Problem Solution Code..."}

#### Understanding the Core Idea {id="core-idea_d1_2" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage the recursive nature of the Josephus problem to calculate the
winner's position efficiently.
Instead of simulating the game step-by-step, it uses a mathematical relationship between
the survivor's position in games with $n$ and $n-1$ players.

- **Recursive Formulation:** The solution is built on the idea that the survivor's position in a game with $n$ players
  can be derived from the survivor's position in a game with $n-1$ players.
- **Position Transformation:** The key mathematical relationship used is `(survivor_position + k) % n`, which adjusts
  the survivor's position from an ($n-1$)-player game to an $n$-player game.
- **Bottom-up Calculation:** The solution starts from the base case of one player and builds up to $n$ players through
  recursive calls.

> **Key Insight:**
> The recursive formula `(survivor_position + k) % players` elegantly handles the circular nature of
> the game without explicitly simulating the elimination process.
> This allows for a much more efficient solution compared to direct simulation.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_2" collapsible="true" default-state="expanded"}

1. **Helper Function Definition:**
   ```python
   def simulate_game(players: int, step: int) -> int:
   ```
   This inner function is defined to handle the recursive calculations.
   It takes the current number of players and the step size as parameters.

2. **Base Case:**
   ```python
   if players == 1:
       return 0
   ```
   When only one player remains, they are at position 0 (0-based indexing).
   This serves as the stopping condition for the recursion.

3. **Recursive Case:**
   ```python
   survivor_position = simulate_game(players - 1, step)
   ```
   We recursively calculate the survivor's position for a game with one less player.
   This builds the solution from the bottom up.

4. **Position Adjustment:**
   ```python
   return (survivor_position + step) % players
   ```
   We adjust the survivor's position from the (n-1)-player game to the n-player game.
   Adding `step` moves the position forward, and the modulo operation wraps it around the circle if necessary.

5. **Main Function Call and Result Conversion:**
   ```python
   return simulate_game(n, k) + 1
   ```
   We call the helper function with the initial number of players and step size.
   The result is then converted to 1-based indexing by adding 1.

---

#### Complexity Analysis {id="complexity-analysis_d1_2" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of players.
  This is because the function makes exactly $n$ recursive calls, each performing constant time operations
  (addition and modulo).
  Despite being recursive, the linear nature of the recursion leads to a linear time complexity.

**Space Complexity:**

- $O(n)$, where $n$ is the number of players.
  This space complexity is due to the recursion stack.
  In the worst case, the recursion will go $n$ levels deep before reaching the base case,
  resulting in $n$ stack frames being stored simultaneously.

---

#### Example {id="example_d1_2" collapsible="true" default-state="expanded"}

**Input:**

```python
n = 6
k = 5
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - The function `findTheWinner2(n=6, k=5)` is called.
    - It immediately calls the helper function `simulate_game(6, 5)`.

2. **Main Recursive Process:**

    - **Recursive Call: simulate_game(6, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(5, 5)`

    - **Recursive Call: simulate_game(5, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(4, 5)`

    - **Recursive Call: simulate_game(4, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(3, 5)`

    - **Recursive Call: simulate_game(3, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(2, 5)`

    - **Recursive Call: simulate_game(2, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(1, 5)`

    - **Recursive Call: simulate_game(1, 5)**
        - Base case reached: only one player remains
        - Returns position 0

3. **Unwinding the Recursion:**
    - **simulate_game(2, 5)**:
        - Calculates new position: (0 + 5) % 2 = 1
        - Returns 1
    - **simulate_game(3, 5)**:
        - Calculates new position: (1 + 5) % 3 = 0
        - Returns 0
    - **simulate_game(4, 5)**:
        - Calculates new position: (0 + 5) % 4 = 1
        - Returns 1
    - **simulate_game(5, 5)**:
        - Calculates new position: (1 + 5) % 5 = 1
        - Returns 1
    - **simulate_game(6, 5)**:
        - Calculates new position: (1 + 5) % 6 = 0
        - Returns 0

4. **Visual Aids:**

   The following image represents the recursive process for the example input `n = 6, k = 5`.
   Each row represents a recursive call, with the top row being the base case.
   The green elements represent the survivor's position at each step, and the arrows show how the position is 
   calculated and passed up through the recursive calls.

   ![july08-2024-ap2-visualization.png](july08-2024-ap2-visualization.png)

   Recursive Calls Summary:

   | Players | Step | Case           | Survivor Position |
   |---------|------|----------------|-------------------|
   | 6       | 5    | Recursive case | 0                 |
   | 5       | 5    | Recursive case | 1                 |
   | 4       | 5    | Recursive case | 1                 |
   | 3       | 5    | Recursive case | 0                 |
   | 2       | 5    | Recursive case | 1                 |
   | 1       | 5    | Base case      | 0                 |

5. **Result Calculation/Final Steps:**
    - The recursive function returns 0 (0-indexed result).
    - The main function adds 1 to convert to 1-indexed: 0 + 1 = 1
    - Return 1 as the final result.

The winner of the game is player 1 (in 1-indexed form).

---

### Approach 3: Iterative Josephus Problem Solution {id="approach_d1_3" collapsible="true" default-state="expanded"}

```Python
def findTheWinner3(n: int, k: int) -> int:
    """
    Determines the winner of a circular elimination game among `n` players.

    This function solves the Josephus problem iteratively by simulating the
    game from 2 players up to `n` players. It calculates the survivor's
    position for each intermediate game state, using the result from the
    previous state. This method efficiently computes the winner's position
    without explicitly simulating the entire game process.

    The time complexity of this solution is O(n), where `n` is the number of
    players. This is because the function iterates from 2 to `n`, performing
    constant time operations in each iteration. The space complexity is O(1)
    as it uses only a constant amount of extra space regardless of the input
    size.
    """
    survivor_position = 0

    # Simulate the game for increasing circle sizes
    for circle_size in range(2, n + 1):
        survivor_position = (survivor_position + k) % circle_size

    # Convert the result to 1-based indexing
    return survivor_position + 1
```

{collapsible="true" default-state="expanded" collapsed-title="Iterative Josephus Problem Solution Code..."}

#### Understanding the Core Idea {id="core-idea_d1_3" collapsible="true" default-state="expanded"}

The central concept of this solution is to solve the Josephus problem iteratively, building up the solution from smaller
game sizes to the target size.
It leverages the mathematical relationship between survivor positions in games of consecutive sizes.

- **Iterative Build-up:** The solution starts with a trivial game of one player and iteratively calculates the survivor's
  position for games of increasing sizes up to n players.
- **Position Transformation:** Similar to the recursive approach, it uses the
  formula `(survivor_position + k) % circle_size` to adjust the survivor's position as the game size increases.
- **In-place Calculation:** Unlike the simulation approach, this method doesn't maintain a list of players, instead
  working directly with the survivor's position.

> **Key Insight:**
> By iteratively building up the solution, we avoid both the space overhead of explicit simulation and
> the stack overhead of recursion, while maintaining the elegant mathematical relationship used in the recursive
> approach.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_3" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   survivor_position = 0
   ```
   We start with a survivor position of 0, which represents the winner's position in a trivial 1-player game.

2. **Iterative Calculation Loop:**
   ```python
   for circle_size in range(2, n + 1):
   ```
   This loop iterates from 2 to $n$, calculating the survivor's position for each game size.
   We start from 2 because the 1-player case is trivially handled by the initialization.

3. **Position Adjustment:**
   ```python
   survivor_position = (survivor_position + k) % circle_size
   ```
   For each circle size, we adjust the survivor's position from the previous game size.
   Adding $k$ simulates the counting process,
   and the modulo operation wraps the position around the current circle size if necessary.

4. **Result Conversion and Return:**
   ```python
   return survivor_position + 1
   ```
   After the loop completes, `survivor_position` holds the winner's position for the n-player game in 0-based indexing.
   We add 1 to convert to 1-based indexing as required by the problem statement.

---

#### Complexity Analysis {id="complexity-analysis_d1_3" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of players.
  This is because the function iterates from 2 to $n$, performing a constant number of operations (addition and modulo)
  in each iteration.
  Despite solving the problem for all game sizes from 2 to $n$,
  the linear nature of the iteration results in a linear time complexity.

**Space Complexity:**

- $O(1)$, or constant space.
  This solution uses only a fixed amount of additional space
  (the `survivor_position` variable) regardless of the input size.
  It doesn't use any data structures that grow with the input, nor does it use
  recursion that would create a variable-sized call stack.

---

#### Example {id="example_d1_3" collapsible="true" default-state="expanded"}

**Input:**

```python
n = 6
k = 5
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - Set `survivor_position = 0`, representing the initial position of the survivor in a hypothetical 1-player game.

2. **Main Loop (Iterative Calculation):**

    - **Iteration 1 (circle size 2):**
        - Current state: `survivor_position = 0`, `circle_size = 2`
        - Calculation: `new_position = (0 + 5) % 2 = 1`
        - Update `survivor_position` to 1

    - **Iteration 2 (circle size 3):**
        - Current state: `survivor_position = 1`, `circle_size = 3`
        - Calculation: `new_position = (1 + 5) % 3 = 0`
        - Update `survivor_position` to 0

    - **Iteration 3 (circle size 4):**
        - Current state: `survivor_position = 0`, `circle_size = 4`
        - Calculation: `new_position = (0 + 5) % 4 = 1`
        - Update `survivor_position` to 1

    - **Iteration 4 (circle size 5):**
        - Current state: `survivor_position = 1`, `circle_size = 5`
        - Calculation: `new_position = (1 + 5) % 5 = 1`
        - `survivor_position` remains 1

    - **Iteration 5 (circle size 6):**
        - Current state: `survivor_position = 1`, `circle_size = 6`
        - Calculation: `new_position = (1 + 5) % 6 = 0`
        - Update `survivor_position` to 0

3. **Loop Termination:**
    - The loop terminates when `circle_size` reaches `n` (6 in this case).
    - Final state of `survivor_position`: 0

4. **Visual Aids:**

   The following image represents the iterative process for the example input `n = 6, k = 5`. 
   Each row represents a circle of increasing size,
   with the green element representing the survivor's position at each step.
   The arrows and labels show how the position is calculated from one step to the next.

   ![july08-2024-ap3-visualization.png](july08-2024-ap3-visualization.png)

   Iteration Summary:

   | Circle Size | Survivor Position |
   |-------------|-------------------|
   | 2           | 1                 |
   | 3           | 0                 |
   | 4           | 1                 |
   | 5           | 1                 |
   | 6           | 0                 |

5. **Result Calculation/Final Steps:**
    - The final `survivor_position` is 0 (0-indexed result).
    - Convert to 1-indexed by adding 1: 0 + 1 = 1
    - Return 1 as the final result.

The winner of the game is player 1 (in 1-indexed form).

---

## July 9 -> 1701. Average Waiting Time {collapsible="true" default-state="collapsed"}

There is a restaurant with a single chef.
You are given an array `customers`, where `customers[i] = [arrival_i, time_i]:`

- `arrival_i` is the arrival time of the `ith` customer. The arrival times are sorted in **non-decreasing** order.
- `time_i` is the time needed to prepare the order of the `ith` customer.

When a customer arrives, they give the chef their order, and the chef starts preparing it once they are idle.
The customer waits till the chef finishes preparing his order.
The chef does not prepare food for more than one customer at a time.
The chef prepares food for customers **in the order they were given in the input**.

Return *the **average** waiting time of all customers*.
Solutions within `10^(-5)` from the actual answer are considered accepted.

**Example 1:**

- **Input:** customers = [[1,2],[2,5],[4,3]]
- **Output:** 5.00000
- **Explanation:**
    1. The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and
       finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.
    2. The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes
       at time 8, so the waiting time of the second customer is 8 - 2 = 6.
    3. The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at
       time 11, so the waiting time of the third customer is 11 - 4 = 7.
       So the average waiting time = (2 + 6 + 7) / 3 = 5.

**Example 2:**

- **Input:** customers = [[5,2],[5,4],[10,3],[20,1]]
- **Output:** 3.25000
- **Explanation:**

1. The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and
   finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.
2. The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at
   time 11, so the waiting time of the second customer is 11 - 5 = 6.
3. The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at
   time 14, so the waiting time of the third customer is 14 - 10 = 4.
4. The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and
   finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
   So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.

**Constraints:**

- `1 <= customers.length <= 10^5`
- `1 <= arrival_i, time_i <= 10^4`
- `arrival_i <= arrival_(i+1)`

---

### Approach 1: Linear Simulation {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
def averageWaitingTime1(customers: List[List[int]]) -> float:
    """
    Calculates the average waiting time for customers in a restaurant with a
    single chef.

    This function simulates the order processing in a restaurant where
    customers arrive at different times and have varying food preparation
    times. It uses a greedy approach, processing orders sequentially as they
    arrive. The key insight is tracking the chef's availability
    (`order_finish_time`) and updating it based on either the next customer's
    arrival or the completion of the previous order, whichever is later.

    The time complexity of this solution is O(n), where `n` is the number of
    customers, because it iterates through the customer list exactly once.
    The space complexity is O(1) as it uses only a constant amount of extra
    space regardless of input size.
    """
    order_finish_time, total_customer_wait_time = 0, 0

    for arrival_time, prep_time in customers:
        # Start cooking order when the customer arrives or when the previous
        # order is finished (whichever is later)
        order_finish_time = max(arrival_time, order_finish_time) + prep_time
        total_customer_wait_time += order_finish_time - arrival_time

    average_wait_time = total_customer_wait_time / len(customers)
    return average_wait_time
```

{collapsible="true" default-state="expanded" collapsed-title="Linear Simulation Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to simulate the chef's order processing in real-time, leveraging a linear scan
through the customer list to calculate waiting times efficiently.
This approach mimics the actual process of a single chef handling orders as they come in.

- **Time Tracking:** The solution maintains a running `order_finish_time` to keep track of when the chef will be
  available next.
- **Greedy Processing:** Orders are processed greedily in the sequence they arrive, without any optimization or
  reordering.
- **Cumulative Wait Time:** The total waiting time is accumulated as each order is processed, allowing for a simple
  average calculation at the end.

> **Key Insight:** The solution elegantly handles both idle and busy periods for the chef by using the `max()`
> function to determine the start time of each order preparation.
> This ensures that the chef starts cooking immediately if they're idle, or waits until they finish the previous order
> if they're busy.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   order_finish_time, total_customer_wait_time = 0, 0
   ```
   The function initializes two key variables: `order_finish_time` to track when the chef will next be available,
   and `total_customer_wait_time` to accumulate the total waiting time across all customers.

2. **Iterating Through Customers:**
   ```python
   for arrival_time, prep_time in customers:
   ```
   This loop processes each customer's order sequentially, unpacking their arrival time and preparation time.
   This approach aligns with the problem statement that orders are prepared in the given input order.

3. **Calculating Order Finish Time:**
   ```python
   order_finish_time = max(arrival_time, order_finish_time) + prep_time
   ```
   This line is crucial as it determines when the current order will be finished.
   It uses `max()` to handle two scenarios:
    - If the chef is idle (`order_finish_time` < `arrival_time`), cooking starts at `arrival_time`.
    - If the chef is busy (`order_finish_time` > `arrival_time`), cooking starts when the previous order finishes.
      The preparation time is then added to this start time to get the new `order_finish_time`.

4. **Calculating and Accumulating Wait Time:**
   ```python
   total_customer_wait_time += order_finish_time - arrival_time
   ```
   The waiting time for each customer is the difference between when their order is finished and when they arrived.
   This is added to the running total of wait times.

5. **Calculating Average Wait Time:**
   ```python
   average_wait_time = total_customer_wait_time / len(customers)
   return average_wait_time
   ```
   After processing all customers, the function calculates the average wait time by dividing the total wait time by the
   number of customers, then returns this value.

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of customers.
  This is because the function iterates through the customer list exactly once,
  performing constant-time operations for each customer.

**Space Complexity:**

- $O(1)$, or constant space.
  This is because the function uses only a fixed amount of additional space
  (`order_finish_time` and `total_customer_wait_time`) regardless of the input size.
  It doesn't create any data structures that grow with the input.

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

**Input:**

```python
customers = [[5, 2], [5, 4], [10, 3], [20, 1]]
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - Initialize `order_finish_time = 0` (representing when the chef will be available next)
    - Initialize `total_customer_wait_time = 0` (to accumulate total waiting time for all customers)

2. **Main Loop (Processing each customer):**

    - **Iteration 1 (Customer 1):**
        - Current state: `order_finish_time = 0`, `total_customer_wait_time = 0`
        - Customer arrives at time 5 with order prep time 2
        - Calculate new `order_finish_time`:
            - `max(5, 0) + 2 = 7` (chef starts at customer's arrival time)
        - Calculate customer wait time: `7 - 5 = 2`
        - Update `total_customer_wait_time`: `0 + 2 = 2`
        - Update `order_finish_time` to 7

    - **Iteration 2 (Customer 2):**
        - Current state: `order_finish_time = 7`, `total_customer_wait_time = 2`
        - Customer arrives at time 5 with order prep time 4
        - Calculate new `order_finish_time`:
            - `max(5, 7) + 4 = 11` (chef starts after finishing the previous order)
        - Calculate customer wait time: `11 - 5 = 6`
        - Update `total_customer_wait_time`: `2 + 6 = 8`
        - Update `order_finish_time` to 11

    - **Iteration 3 (Customer 3):**
        - Current state: `order_finish_time = 11`, `total_customer_wait_time = 8`
        - Customer arrives at time 10 with order prep time 3
        - Calculate new `order_finish_time`:
            - `max(10, 11) + 3 = 14` (chef starts after finishing the previous order)
        - Calculate customer wait time: `14 - 10 = 4`
        - Update `total_customer_wait_time`: `8 + 4 = 12`
        - Update `order_finish_time` to 14

    - **Iteration 4 (Customer 4):**
        - Current state: `order_finish_time = 14`, `total_customer_wait_time = 12`
        - Customer arrives at time 20 with order prep time 1
        - Calculate new `order_finish_time`:
            - `max(20, 14) + 1 = 21` (chef starts at customer's arrival time)
        - Calculate customer wait time: `21 - 20 = 1`
        - Update `total_customer_wait_time`: `12 + 1 = 13`
        - Update `order_finish_time` to 21

3. **Visual Aid:**

   | Customer | Arrival Time | Prep Time | Order Finish Time | Wait Time | Total Wait Time |
   |----------|--------------|-----------|-------------------|-----------|-----------------|
   | 1        | 5            | 2         | 7                 | 2         | 2               |
   | 2        | 5            | 4         | 11                | 6         | 8               |
   | 3        | 10           | 3         | 14                | 4         | 12              |
   | 4        | 20           | 1         | 21                | 1         | 13              |

4. **Result Calculation:**
    - Calculate average waiting time:
      `total_customer_wait_time / number_of_customers = 13 / 4 = 3.25`

The function returns 3.25, which is the average waiting time for all customers.

---

## July 10 -> 1598. Crawler Log Folder {collapsible="true" default-state="collapsed"}

The LeetCode file system keeps a log each time some user performs a *change folder* operation.

The operations are described below:

- `"../"` : Move to the parent folder of the current folder.
  (If you are already in the main folder, **remain in the same folder**).
- `"./"` : Remain in the same folder.
- `"x/"` : Move to the child folder named `x` (This folder is **guaranteed to always exist**).

You are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step.

The file system starts in the main folder, then the operations in `logs` are performed.

Return *the minimum number of operations needed to go back to the main folder after the change folder operations.*

**Example 1:**

![july10-2024-ex1.png](july10-2024-ex1.png)

- **Input:** logs = ["d1/","d2/","../","d21/","./"]
- **Output:** 2
- **Explanation:** Use this change folder operation "../" 2 times and go back to the main folder.

**Example 2:**

![july10-2024-ex2.png](july10-2024-ex2.png)

- **Input:** logs = ["d1/","d2/","./","d3/","../","d31/"]
- **Output:** 3

**Example 3:**

- **Input:** logs = ["d1/","../","../","../"]
- **Output**: 0

**Constraints:**

- `1 <= logs.length <= 10^3`
- `2 <= logs[i].length <= 10`
- `logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`.
- `logs[i]` follows the format described in the statement.
- Folder names consist of lowercase English letters and digits.

---

### Approach 1: Integer Depth Tracking {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
def minOperations1(logs: List[str]) -> int:
    """
    Calculates the minimum number of operations needed to return to the main
    folder after a series of folder operations.

    This function simulates folder navigation by tracking the current depth
    relative to the main folder. It iterates through each operation in the
    logs, updating the depth accordingly. The key insight is representing
    folder depth as an integer, where 0 is the main folder, and each
    subfolder increases  the depth by 1. This allows for efficient tracking
    without needing to maintain a full path structure.

    The time complexity of this solution is O(n), where `n` is the number of
    operations in logs, because we iterate through each operation exactly once.
    The space complexity is O(1) as we only use a single integer variable
    regardless of input size.
    """
    folder_depth = 0

    for operation in logs:
        if operation == "./":
            continue  # No change in depth for staying in the same folder
        if operation == "../":
            # Move up one level, but never go above the main folder (depth 0)
            folder_depth = max(0, folder_depth - 1)
        else:
            # Moving into a subfolder increases depth by 1
            folder_depth += 1

    return folder_depth
```

{collapsible="true" default-state="expanded" collapsed-title="Integer Depth Tracking Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a single integer variable to represent the current folder depth.
This approach simplifies the problem of tracking folder navigation into basic arithmetic operations.

- **Depth Representation:** The main folder is represented by depth 0, and each subfolder increases the depth by 1.
- **Navigational Operations:** Moving into a subfolder increases depth, moving up decreases it, and staying in the same
  folder doesn't change the depth.
- **Boundary Handling:** The solution prevents going above the main folder by using the `max()` function.

> **Key Insight:**
> By representing folder depth as an integer, we eliminate the need for complex data structures like
> stacks or strings to represent the full path, resulting in a memory-efficient solution.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   folder_depth = 0
   ```
   We initialize `folder_depth` to 0, representing the starting position in the main folder.
   This variable will keep track of our current depth throughout the navigation process.

2. **Iterating Through Operations:**
   ```python
   for operation in logs:
   ```
   We iterate through each operation in the `logs` list.
   This allows us to process each folder change sequentially, simulating the user's navigation.

3. **Handling "Stay in the Same Folder" Operation:**
   ```python
   if operation == "./":
       continue
   ```
   When we encounter "./", we simply continue to the next operation without changing `folder_depth`.
   This efficiently handles the "stay in the same folder" operation without unnecessary computations.

4. **Handling "Move Up" Operation:**
   ```python
   if operation == "../":
       folder_depth = max(0, folder_depth - 1)
   ```
   For "../", we decrease `folder_depth` by 1, but use `max()` to ensure it never goes below 0.
   This elegantly handles moving up from the main folder without requiring an additional conditional check.

5. **Handling "Move to Subfolder" Operation:**
   ```python
   else:
       folder_depth += 1
   ```
   For any other operation (which represents moving into a subfolder), we increment `folder_depth` by 1.
   This assumes all other operations are valid "x/" commands as per the problem statement.

6. **Result Calculation/Return:**
   ```python
   return folder_depth
   ```
   After processing all operations, `folder_depth` represents the current depth from the main folder.
   This is exactly the number of "../" operations needed to return to the main folder, so we return it directly.

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of operations in the `logs` list.
  This is because we iterate through each operation exactly once, performing constant-time operations for each.

**Space Complexity:**

- $O(1)$, as we only use a single integer variable `folder_depth` regardless of the input size.
  This solution doesn't require any additional data structures that grow with the input size.

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

**Input:**

```python
logs = ['d1/', 'd2/', './', 'd3/', '../', 'd31/']
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - We start by initializing `folder_depth = 0`, representing that we're in the main folder.

2. **Main Loop (Processing each operation):**

    - **Iteration 1:**
        - Operation: `'d1/'`
        - This is a move to child folder operation.
        - Action: Increment `folder_depth` from 0 to 1.
        - We are now one level deep in the folder structure.

    - **Iteration 2:**
        - Operation: `'d2/'`
        - Another move to child folder operation.
        - Action: Increment `folder_depth` from 1 to 2.
        - We are now two levels deep.

    - **Iteration 3:**
        - Operation: `'./'`
        - This operation means stay in the same folder.
        - Action: No change to `folder_depth`, it remains 2.

    - **Iteration 4:**
        - Operation: `'d3/'`
        - Another move to child folder operation.
        - Action: Increment `folder_depth` from 2 to 3.
        - We are now three levels deep.

    - **Iteration 5:**
        - Operation: `'../'`
        - This is a move to parent folder operation.
        - Action: Decrement `folder_depth`, but ensure it doesn't go below 0.
        - Calculation: `max(0, 3 - 1) = 2`
        - `folder_depth` is updated from 3 to 2.

    - **Iteration 6:**
        - Operation: `'d31/'`
        - Another move to child folder operation.
        - Action: Increment `folder_depth` from 2 to 3.
        - We end up three levels deep again.

3. **Visual Aid:**

   | Operation # | Command | Resulting Depth |
   |-------------|---------|-----------------|
   | 1           | d1/     | 1               |
   | 2           | d2/     | 2               |
   | 3           | ./      | 2               |
   | 4           | d3/     | 3               |
   | 5           | ../     | 2               |
   | 6           | d31/    | 3               |

4. **Result Calculation:**
    - After processing all operations, our final `folder_depth` is 3.
    - This means we are three levels deep in the folder structure.
    - To return to the main folder, we need to perform three `'../'` operations.

The function returns 3, which represents the minimum number of `'../'` operations needed to return to the main folder
from our current position.

---

### Approach 2: Stack-Based Folder Tracking {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
def minOperations2(logs: List[str]) -> int:
    """
    Calculates the minimum number of operations needed to return to the main
    folder after a series of folder operations.
    
    This function simulates folder navigation using a stack data structure.
    Each subfolder is pushed onto the stack, while moving up removes the top
    folder. This approach closely mimics the actual folder structure,
    providing a more intuitive representation of the file system hierarchy.
    The stack's size at the end directly represents the depth of the current
    folder and thus the number of operations needed to return to the main
    folder.

    The time complexity of this solution is O(n), where `n` is the number of
    operations in logs, as we process each operation once with constant-time
    operations. The space complexity is O(n) in the worst case, where all
    operations lead to subfolders, resulting in a stack that could grow to
    the size of the input.
    """
    folder_stack = []

    for operation in logs:
        if operation == "./":
            continue  # No change in folder structure
        elif operation == "../":
            if folder_stack:
                folder_stack.pop()  # Move up one level if not in main folder
        else:
            folder_stack.append(operation)  # Enter a new subfolder

    return len(folder_stack)
```

{collapsible="true" default-state="expanded" collapsed-title="Stack-Based Folder Tracking Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a stack data structure to simulate the folder hierarchy.
This approach provides a more intuitive representation of the file system structure.

- **Stack Representation:** Each element in the stack represents a subfolder, with the bottom of the stack being the
  main folder.
- **Navigational Operations:** Moving into a subfolder pushes it onto the stack, moving up pops the top folder, and
  staying in the same folder does nothing to the stack.
- **Depth Calculation:** The depth of the current folder is directly represented by the size of the stack.

> **Key Insight:**
> By using a stack, we maintain the entire path history, which could be beneficial if the problem requirements were
> extended to include path information or backtracking.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   folder_stack = []
   ```
   We initialize an empty list `folder_stack` to represent our folder structure.
   The empty stack corresponds to being in the main folder.

2. **Iterating Through Operations:**
   ```python
   for operation in logs:
   ```
   We iterate through each operation in the `logs` list, processing them sequentially to simulate the user's navigation.

3. **Handling "Stay in the Same Folder" Operation:**
   ```python
   if operation == "./":
       continue
   ```
   When we encounter "./", we simply continue to the next operation without modifying the stack.
   This efficiently
   handles the "stay in the same folder" operation without unnecessary computations.

4. **Handling "Move Up" Operation:**
   ```python
   elif operation == "../":
       if folder_stack:
           folder_stack.pop()
   ```
   For "../", we check if the stack is not empty (ensuring we're not in the main folder) and then pop the top element.
   This simulates moving up one level in the folder hierarchy.
   The check prevents attempts to move above the main folder.

5. **Handling "Move to Subfolder" Operation:**
   ```python
   else:
       folder_stack.append(operation)
   ```
   For any other operation (which represents moving into a subfolder), we append it to the stack.
   This simulates entering a new subfolder by adding it to our current path.

6. **Result Calculation/Return:**
   ```python
   return len(folder_stack)
   ```
   After processing all operations, the length of `folder_stack` represents the current depth from the main folder.
   This is exactly the number of "../" operations needed to return to the main folder, so we return it directly.

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of operations in the `logs` list.
  This is because we iterate through each operation exactly once,
  and each operation (push, pop, or continue) is performed in constant time.

**Space Complexity:**

- $O(n)$ in the worst case, where $n$ is the number of operations in the `logs` list.
  This occurs when all operations are "move to subfolder" operations, causing the stack to grow to the size of the
  input.
  In the best case (all operations are "../" or "./"), the space complexity would be $O(1)$.

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

## July 11 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

## July 12 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

## July 13 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

## July 14 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---
