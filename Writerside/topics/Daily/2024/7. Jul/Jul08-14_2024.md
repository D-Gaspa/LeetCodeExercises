# July 2024, Week 2: July 8th - July 14th

## July 8 -> 1823. Find the Winner of the Circular Game {collapsible="true" default-state="collapsed"}

There are `n` friends that are playing a game.
The friends are sitting in a circle and are numbered from `1` to `n` in **clockwise order**.
More formally, moving clockwise from the `ith` friend brings you to the `(i+1)th` friend
for `1 <= i < n`, and moving clockwise from the `nth` friend brings you to the `1st` friend.

The rules of the game are as follows:

1. **Start** at the `1st` friend.
2. Count the next `k` friends in the clockwise direction **including** the friend you started at.
   The counting wraps around the circle and may count some friends more than once.
3. The last friend you counted leaves the circle and loses the game.
4. If there is still more than one friend in the circle, go back to step `2` **starting** from the friend **immediately
   clockwise** of the friend who just lost and repeat.
5. Else, the last friend in the circle wins the game.

Given the number of friends, `n`, and an integer `k`, return *the winner of the game*.

**Example 1:**

![july08-2024-ex1.png](july08-2024-ex1.png)

- **Input:** n = 5, k = 2
- **Output:** 3
- **Explanation:** Here are the steps of the game:
    1. Start at friend 1.
    2. Count two friends clockwise, which are friends 1 and 2.
    3. Friend 2 leaves the circle. Next start is friend 3.
    4. Count two friends clockwise, which are friends 3 and 4.
    5. Friend 4 leaves the circle. Next start is friend 5.
    6. Count two friends clockwise, which are friends 5 and 1.
    7. Friend 1 leaves the circle. Next start is friend 3.
    8. Count two friends clockwise, which are friends 3 and 5.
    9. Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.

**Example 2:**

- **Input:** n = 6, k = 5
- **Output:** 1
- **Explanation:** The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.

**Constraints:**

- `1 <= k <= n <= 500`

---

### Approach 1: Simulation with Deque {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def findTheWinner1(n: int, k: int) -> int:
    """
    Determines the winner of a circular elimination game among `n` players.

    This function simulates the game using a deque (double-ended queue) to
    represent the circle of players. It efficiently rotates the deque to move
    players and eliminates them until only one player remains. The deque
    allows for O(1) operations at both ends, which is crucial for the
    efficient simulation of the circular nature of the game.

    The time complexity of this solution is O(n * k), where `n` is the number
    of players and `k` is the counting interval. This is because for each
    elimination (which happens n-1 times), we perform k rotations of the
    deque. The space complexity is O(n) as we store all `n` players in the deque
    initially.
    """
    active_players = deque(range(n))
    while len(active_players) > 1:
        # Move k-1 players to the end of the queue
        for _ in range(k - 1):
            active_players.append(active_players.popleft())
        # Remove the k-th player
        active_players.popleft()
    # Convert to 1-based indexing for the result
    return active_players[0] + 1
```

{collapsible="true" default-state="expanded" collapsed-title="Simulation with Deque Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a deque (double-ended queue) to simulate the circular elimination
game efficiently.
This approach directly models the game's mechanics by rotating players and removing them as per the
rules.

- **Circular Nature Simulation:** The deque allows for efficient rotation of players, mimicking the circular arrangement
  described in the problem.
- **Player Elimination:** By using the deque's `popleft()` method, we can easily remove players from the game when they
  are counted out.
- **Efficient Rotation:** The deque's ability to perform $O(1)$ operations at both ends makes it ideal for simulating the
  counting process without the need for complex index calculations.

> **Key Insight:**
> The use of a deque allows us to avoid the overhead of managing circular indexing manually.
> By moving players from the front to the back of the deque, we naturally simulate the circular counting process.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   active_players = deque(range(n))
   ```
   We create a deque containing integers from 0 to `n-1`, representing the players.
   Using 0-based indexing simplifies the simulation process.

2. **Game Simulation Loop:**
   ```python
   while len(active_players) > 1:
   ```
   This loop continues until only one player remains, simulating the entire game process.

3. **Player Rotation:**
   ```python
   for _ in range(k - 1):
       active_players.append(active_players.popleft())
   ```
   We rotate `k-1` players from the front to the back of the deque.
   This simulates the counting process without actually removing any players yet.
   We use `k-1` because the `k`th player will be removed in the next step.

4. **Player Elimination:**
   ```python
   active_players.popleft()
   ```
   After the rotation, the player at the front of the deque is the `k`th player in the count.
   We remove this player using `popleft()`, simulating their elimination from the game.

5. **Result Calculation/Return:**
   ```python
   return active_players[0] + 1
   ```
   Once the loop ends, only one player remains in the deque.
   We return this player's number, adding 1 to convert from 0-based to 1-based indexing as required by the
   problem statement.

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n * k)$, where $n$ is the number of players and $k$ is the counting interval.
  This is because we perform $n-1$ eliminations (as we start with $n$ players and end with 1),
  and for each elimination, we rotate the deque $k$ times.

**Space Complexity:**

- $O(n)$, where $n$ is the number of players.
  This is because we store all $n$ players in the deque initially.
  The space used remains constant throughout the execution of the algorithm, even as players are eliminated.

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

**Input:**

```python
n = 6
k = 5
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - Create a `deque` called `active_players` with values `[0, 1, 2, 3, 4, 5]`, representing the players in 0-indexed
      form.

2. **Main Loop (Elimination Process):**

    - **Iteration 1:**
        - Current active players: `[0, 1, 2, 3, 4, 5]`
        - We need to remove the fifth player (k=5)
        - Rotate the deque 4 times (k-1):
            - Move 0 to the end: `[1, 2, 3, 4, 5, 0]`
            - Move 1 to the end: `[2, 3, 4, 5, 0, 1]`
            - Move 2 to the end: `[3, 4, 5, 0, 1, 2]`
            - Move 3 to the end: `[4, 5, 0, 1, 2, 3]`
        - Remove the front player (4)
        - Resulting deque: `[5, 0, 1, 2, 3]`

    - **Iteration 2:**
        - Current active players: `[5, 0, 1, 2, 3]`
        - Rotate 4 times:
            - Final state after rotation: `[3, 5, 0, 1, 2]`
        - Remove the front player (3)
        - Resulting deque: `[5, 0, 1, 2]`

    - **Iteration 3:**
        - Current active players: `[5, 0, 1, 2]`
        - Rotate 4 times:
            - Final state after rotation: `[5, 0, 1, 2]`
        - Remove the front player (5)
        - Resulting deque: `[0, 1, 2]`

    - **Iteration 4:**
        - Current active players: `[0, 1, 2]`
        - Rotate 4 times:
            - Final state after rotation: `[1, 2, 0]`
        - Remove the front player (1)
        - Resulting deque: `[2, 0]`

    - **Iteration 5:**
        - Current active players: `[2, 0]`
        - Rotate 4 times:
            - Final state after rotation: `[2, 0]`
        - Remove the front player (2)
        - Resulting deque: `[0]`

3. **Loop Termination:**
    - The loop terminates when only one player remains in the `active_players` deque.
    - Final state of `active_players`: `[0]`

4. **Visual Aids:**

   The following image represents the simulation process for the example input `n = 6, k = 5` where the red elements 
   represent the players that will be removed in each round.
   The visualization shows the rotation of the deque and the elimination of players until only one player remains.

   ![july08-2024-ap1-visualization.png](july08-2024-ap1-visualization.png)

   Iteration Summary:

   | Round | Active Players  | Removed Player |
   |-------|-----------------|----------------|
   | 1     | [5, 0, 1, 2, 3] | 4              |
   | 2     | [5, 0, 1, 2]    | 3              |
   | 3     | [0, 1, 2]       | 5              |
   | 4     | [2, 0]          | 1              |
   | 5     | [0]             | 2              |

5. **Result Calculation/Final Steps:**
    - The last remaining player in `active_players` is 0 (0-indexed).
    - Convert to 1-indexed by adding 1: 0 + 1 = 1
    - Return 1 as the final result.

The winner of the game is player 1 (in 1-indexed form).

---

### Approach 2: Recursive Josephus Problem Solution {id="approach_d1_2" collapsible="true" default-state="expanded"}

```Python
def findTheWinner2(n: int, k: int) -> int:
    """
    Determines the winner of a circular elimination game among `n` players.

    This function employs a recursive approach to solve the Josephus problem.
    Instead of simulating the game directly, it calculates the position of
    the survivor based on  mathematical relationships between game states
    with n and n-1 players. This method leverages the recursive nature of the
    problem to efficiently compute the winner's position.

    The time complexity of this solution is O(n), where `n` is the number of
    players. This is because the function makes `n` recursive calls, each
    doing constant time operations. The space complexity is O(n) due to the
    recursion stack, which can go `n` levels deep.
    """
    def simulate_game(players: int, step: int) -> int:
        """
        Helper function to recursively simulate the game and find the
        survivor's position.
        """
        # Base case: if only one player remains, they are at position 0
        if players == 1:
            return 0

        # Recursive case: calculate the survivor's position
        # for n-1 players and adjust it for n players
        survivor_position = simulate_game(players - 1, step)
        return (survivor_position + step) % players

    # Convert the result to 1-based indexing
    return simulate_game(n, k) + 1
```

{collapsible="true" default-state="expanded" collapsed-title="Recursive Josephus Problem Solution Code..."}

#### Understanding the Core Idea {id="core-idea_d1_2" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage the recursive nature of the Josephus problem to calculate the
winner's position efficiently.
Instead of simulating the game step-by-step, it uses a mathematical relationship between
the survivor's position in games with $n$ and $n-1$ players.

- **Recursive Formulation:** The solution is built on the idea that the survivor's position in a game with $n$ players
  can be derived from the survivor's position in a game with $n-1$ players.
- **Position Transformation:** The key mathematical relationship used is `(survivor_position + k) % n`, which adjusts
  the survivor's position from an ($n-1$)-player game to an $n$-player game.
- **Bottom-up Calculation:** The solution starts from the base case of one player and builds up to $n$ players through
  recursive calls.

> **Key Insight:**
> The recursive formula `(survivor_position + k) % players` elegantly handles the circular nature of
> the game without explicitly simulating the elimination process.
> This allows for a much more efficient solution compared to direct simulation.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_2" collapsible="true" default-state="expanded"}

1. **Helper Function Definition:**
   ```python
   def simulate_game(players: int, step: int) -> int:
   ```
   This inner function is defined to handle the recursive calculations.
   It takes the current number of players and the step size as parameters.

2. **Base Case:**
   ```python
   if players == 1:
       return 0
   ```
   When only one player remains, they are at position 0 (0-based indexing).
   This serves as the stopping condition for the recursion.

3. **Recursive Case:**
   ```python
   survivor_position = simulate_game(players - 1, step)
   ```
   We recursively calculate the survivor's position for a game with one less player.
   This builds the solution from the bottom up.

4. **Position Adjustment:**
   ```python
   return (survivor_position + step) % players
   ```
   We adjust the survivor's position from the (n-1)-player game to the n-player game.
   Adding `step` moves the position forward, and the modulo operation wraps it around the circle if necessary.

5. **Main Function Call and Result Conversion:**
   ```python
   return simulate_game(n, k) + 1
   ```
   We call the helper function with the initial number of players and step size.
   The result is then converted to 1-based indexing by adding 1.

---

#### Complexity Analysis {id="complexity-analysis_d1_2" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of players.
  This is because the function makes exactly $n$ recursive calls, each performing constant time operations
  (addition and modulo).
  Despite being recursive, the linear nature of the recursion leads to a linear time complexity.

**Space Complexity:**

- $O(n)$, where $n$ is the number of players.
  This space complexity is due to the recursion stack.
  In the worst case, the recursion will go $n$ levels deep before reaching the base case,
  resulting in $n$ stack frames being stored simultaneously.

---

#### Example {id="example_d1_2" collapsible="true" default-state="expanded"}

**Input:**

```python
n = 6
k = 5
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - The function `findTheWinner2(n=6, k=5)` is called.
    - It immediately calls the helper function `simulate_game(6, 5)`.

2. **Main Recursive Process:**

    - **Recursive Call: simulate_game(6, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(5, 5)`

    - **Recursive Call: simulate_game(5, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(4, 5)`

    - **Recursive Call: simulate_game(4, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(3, 5)`

    - **Recursive Call: simulate_game(3, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(2, 5)`

    - **Recursive Call: simulate_game(2, 5)**
        - Not a base case, so it makes a recursive call to `simulate_game(1, 5)`

    - **Recursive Call: simulate_game(1, 5)**
        - Base case reached: only one player remains
        - Returns position 0

3. **Unwinding the Recursion:**
    - **simulate_game(2, 5)**:
        - Calculates new position: (0 + 5) % 2 = 1
        - Returns 1
    - **simulate_game(3, 5)**:
        - Calculates new position: (1 + 5) % 3 = 0
        - Returns 0
    - **simulate_game(4, 5)**:
        - Calculates new position: (0 + 5) % 4 = 1
        - Returns 1
    - **simulate_game(5, 5)**:
        - Calculates new position: (1 + 5) % 5 = 1
        - Returns 1
    - **simulate_game(6, 5)**:
        - Calculates new position: (1 + 5) % 6 = 0
        - Returns 0

4. **Visual Aids:**

   The following image represents the recursive process for the example input `n = 6, k = 5`.
   Each row represents a recursive call, with the top row being the base case.
   The green elements represent the survivor's position at each step, and the arrows show how the position is 
   calculated and passed up through the recursive calls.

   ![july08-2024-ap2-visualization.png](july08-2024-ap2-visualization.png)

   Recursive Calls Summary:

   | Players | Step | Case           | Survivor Position |
   |---------|------|----------------|-------------------|
   | 6       | 5    | Recursive case | 0                 |
   | 5       | 5    | Recursive case | 1                 |
   | 4       | 5    | Recursive case | 1                 |
   | 3       | 5    | Recursive case | 0                 |
   | 2       | 5    | Recursive case | 1                 |
   | 1       | 5    | Base case      | 0                 |

5. **Result Calculation/Final Steps:**
    - The recursive function returns 0 (0-indexed result).
    - The main function adds 1 to convert to 1-indexed: 0 + 1 = 1
    - Return 1 as the final result.

The winner of the game is player 1 (in 1-indexed form).

---

### Approach 3: Iterative Josephus Problem Solution {id="approach_d1_3" collapsible="true" default-state="expanded"}

```Python
def findTheWinner3(n: int, k: int) -> int:
    """
    Determines the winner of a circular elimination game among `n` players.

    This function solves the Josephus problem iteratively by simulating the
    game from 2 players up to `n` players. It calculates the survivor's
    position for each intermediate game state, using the result from the
    previous state. This method efficiently computes the winner's position
    without explicitly simulating the entire game process.

    The time complexity of this solution is O(n), where `n` is the number of
    players. This is because the function iterates from 2 to `n`, performing
    constant time operations in each iteration. The space complexity is O(1)
    as it uses only a constant amount of extra space regardless of the input
    size.
    """
    survivor_position = 0

    # Simulate the game for increasing circle sizes
    for circle_size in range(2, n + 1):
        survivor_position = (survivor_position + k) % circle_size

    # Convert the result to 1-based indexing
    return survivor_position + 1
```

{collapsible="true" default-state="expanded" collapsed-title="Iterative Josephus Problem Solution Code..."}

#### Understanding the Core Idea {id="core-idea_d1_3" collapsible="true" default-state="expanded"}

The central concept of this solution is to solve the Josephus problem iteratively, building up the solution from smaller
game sizes to the target size.
It leverages the mathematical relationship between survivor positions in games of consecutive sizes.

- **Iterative Build-up:** The solution starts with a trivial game of one player and iteratively calculates the survivor's
  position for games of increasing sizes up to n players.
- **Position Transformation:** Similar to the recursive approach, it uses the
  formula `(survivor_position + k) % circle_size` to adjust the survivor's position as the game size increases.
- **In-place Calculation:** Unlike the simulation approach, this method doesn't maintain a list of players, instead
  working directly with the survivor's position.

> **Key Insight:**
> By iteratively building up the solution, we avoid both the space overhead of explicit simulation and
> the stack overhead of recursion, while maintaining the elegant mathematical relationship used in the recursive
> approach.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_3" collapsible="true" default-state="expanded"}

### Code Walkthrough

1. **Initialization:**
   ```python
   survivor_position = 0
   ```
   We start with a survivor position of 0, which represents the winner's position in a trivial 1-player game.

2. **Iterative Calculation Loop:**
   ```python
   for circle_size in range(2, n + 1):
   ```
   This loop iterates from 2 to $n$, calculating the survivor's position for each game size.
   We start from 2 because the 1-player case is trivially handled by the initialization.

3. **Position Adjustment:**
   ```python
   survivor_position = (survivor_position + k) % circle_size
   ```
   For each circle size, we adjust the survivor's position from the previous game size.
   Adding $k$ simulates the counting process,
   and the modulo operation wraps the position around the current circle size if necessary.

4. **Result Conversion and Return:**
   ```python
   return survivor_position + 1
   ```
   After the loop completes, `survivor_position` holds the winner's position for the n-player game in 0-based indexing.
   We add 1 to convert to 1-based indexing as required by the problem statement.

---

#### Complexity Analysis {id="complexity-analysis_d1_3" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of players.
  This is because the function iterates from 2 to $n$, performing a constant number of operations (addition and modulo)
  in each iteration.
  Despite solving the problem for all game sizes from 2 to $n$,
  the linear nature of the iteration results in a linear time complexity.

**Space Complexity:**

- $O(1)$, or constant space.
  This solution uses only a fixed amount of additional space
  (the `survivor_position` variable) regardless of the input size.
  It doesn't use any data structures that grow with the input, nor does it use
  recursion that would create a variable-sized call stack.

---

#### Example {id="example_d1_3" collapsible="true" default-state="expanded"}

**Input:**

```python
n = 6
k = 5
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - Set `survivor_position = 0`, representing the initial position of the survivor in a hypothetical 1-player game.

2. **Main Loop (Iterative Calculation):**

    - **Iteration 1 (circle size 2):**
        - Current state: `survivor_position = 0`, `circle_size = 2`
        - Calculation: `new_position = (0 + 5) % 2 = 1`
        - Update `survivor_position` to 1

    - **Iteration 2 (circle size 3):**
        - Current state: `survivor_position = 1`, `circle_size = 3`
        - Calculation: `new_position = (1 + 5) % 3 = 0`
        - Update `survivor_position` to 0

    - **Iteration 3 (circle size 4):**
        - Current state: `survivor_position = 0`, `circle_size = 4`
        - Calculation: `new_position = (0 + 5) % 4 = 1`
        - Update `survivor_position` to 1

    - **Iteration 4 (circle size 5):**
        - Current state: `survivor_position = 1`, `circle_size = 5`
        - Calculation: `new_position = (1 + 5) % 5 = 1`
        - `survivor_position` remains 1

    - **Iteration 5 (circle size 6):**
        - Current state: `survivor_position = 1`, `circle_size = 6`
        - Calculation: `new_position = (1 + 5) % 6 = 0`
        - Update `survivor_position` to 0

3. **Loop Termination:**
    - The loop terminates when `circle_size` reaches `n` (6 in this case).
    - Final state of `survivor_position`: 0

4. **Visual Aids:**

   The following image represents the iterative process for the example input `n = 6, k = 5`. 
   Each row represents a circle of increasing size,
   with the green element representing the survivor's position at each step.
   The arrows and labels show how the position is calculated from one step to the next.

   ![july08-2024-ap3-visualization.png](july08-2024-ap3-visualization.png)

   Iteration Summary:

   | Circle Size | Survivor Position |
   |-------------|-------------------|
   | 2           | 1                 |
   | 3           | 0                 |
   | 4           | 1                 |
   | 5           | 1                 |
   | 6           | 0                 |

5. **Result Calculation/Final Steps:**
    - The final `survivor_position` is 0 (0-indexed result).
    - Convert to 1-indexed by adding 1: 0 + 1 = 1
    - Return 1 as the final result.

The winner of the game is player 1 (in 1-indexed form).

---

## July 9 -> 1701. Average Waiting Time {collapsible="true" default-state="collapsed"}

There is a restaurant with a single chef.
You are given an array `customers`, where `customers[i] = [arrival_i, time_i]:`

- `arrival_i` is the arrival time of the `ith` customer. The arrival times are sorted in **non-decreasing** order.
- `time_i` is the time needed to prepare the order of the `ith` customer.

When a customer arrives, they give the chef their order, and the chef starts preparing it once they are idle.
The customer waits till the chef finishes preparing his order.
The chef does not prepare food for more than one customer at a time.
The chef prepares food for customers **in the order they were given in the input**.

Return *the **average** waiting time of all customers*.
Solutions within `10^(-5)` from the actual answer are considered accepted.

**Example 1:**

- **Input:** customers = [[1,2],[2,5],[4,3]]
- **Output:** 5.00000
- **Explanation:**
    1. The first customer arrives at time 1, the chef takes his order and starts preparing it immediately at time 1, and
       finishes at time 3, so the waiting time of the first customer is 3 - 1 = 2.
    2. The second customer arrives at time 2, the chef takes his order and starts preparing it at time 3, and finishes
       at time 8, so the waiting time of the second customer is 8 - 2 = 6.
    3. The third customer arrives at time 4, the chef takes his order and starts preparing it at time 8, and finishes at
       time 11, so the waiting time of the third customer is 11 - 4 = 7.
       So the average waiting time = (2 + 6 + 7) / 3 = 5.

**Example 2:**

- **Input:** customers = [[5,2],[5,4],[10,3],[20,1]]
- **Output:** 3.25000
- **Explanation:**

1. The first customer arrives at time 5, the chef takes his order and starts preparing it immediately at time 5, and
   finishes at time 7, so the waiting time of the first customer is 7 - 5 = 2.
2. The second customer arrives at time 5, the chef takes his order and starts preparing it at time 7, and finishes at
   time 11, so the waiting time of the second customer is 11 - 5 = 6.
3. The third customer arrives at time 10, the chef takes his order and starts preparing it at time 11, and finishes at
   time 14, so the waiting time of the third customer is 14 - 10 = 4.
4. The fourth customer arrives at time 20, the chef takes his order and starts preparing it immediately at time 20, and
   finishes at time 21, so the waiting time of the fourth customer is 21 - 20 = 1.
   So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.

**Constraints:**

- `1 <= customers.length <= 10^5`
- `1 <= arrival_i, time_i <= 10^4`
- `arrival_i <= arrival_(i+1)`

---

### Approach 1: Approach Name {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
def averageWaitingTime1(customers: List[List[int]]) -> float:
    """
    Calculates the average waiting time for customers in a restaurant with a
    single chef.

    This function simulates the order processing in a restaurant where
    customers arrive at different times and have varying food preparation
    times. It uses a greedy approach, processing orders sequentially as they
    arrive. The key insight is tracking the chef's availability
    (`order_finish_time`) and updating it based on either the next customer's
    arrival or the completion of the previous order, whichever is later.

    The time complexity of this solution is O(n), where `n` is the number of
    customers, because it iterates through the customer list exactly once.
    The space complexity is O(1) as it uses only a constant amount of extra
    space regardless of input size.
    """
    order_finish_time, total_customer_wait_time = 0, 0

    for arrival_time, prep_time in customers:
        # Start cooking order when the customer arrives or when the previous
        # order is finished (whichever is later)
        order_finish_time = max(arrival_time, order_finish_time) + prep_time
        total_customer_wait_time += order_finish_time - arrival_time

    average_wait_time = total_customer_wait_time / len(customers)
    return average_wait_time
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

...

---

## July 10 -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

## July 11 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

## July 12 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

## July 13 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

## July 14 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---
