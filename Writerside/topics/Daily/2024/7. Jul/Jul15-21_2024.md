# July 2024, Week 3: July 15th - July 21st

## July 15 -> 2196. Create Binary Tree From Descriptions {collapsible="true" default-state="collapsed"}

You are given a 2D integer array `descriptions` where `descriptions[i] = [parent_i, child_i, isLeft_i]` indicates
that `parent_i` is the **parent** of `child_i` in a **binary** tree of **unique** values.
Furthermore,

- If `isLeft_i == 1`, then `child_i` is the left child of `parent_i`.
- If `isLeft_i == 0`, then `child_i` is the right child of `parent_i`.

Construct the binary tree described by `descriptions` and return *its **root***.

The test cases will be generated such that the binary tree is **valid**.

**Example 1:**

![july15-2024-ex1.png](july15-2024-ex1.png)

- **Input:** `descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]`
- **Output:** `[50,20,80,15,17,19]`
- **Explanation:** The root node is the node with value 50 since it has no parent.
  The resulting binary tree is shown in the diagram.

**Example 2:**

![july15-2024-ex2.png](july15-2024-ex2.png)

- **Input:** `descriptions = [[1,2,1],[2,3,0],[3,4,1]]`
- **Output:** `[1,2,null,null,3,4]`
- **Explanation:** The root node is the node with value 1 since it has no parent.
  The resulting binary tree is shown in the diagram.

**Constraints:**

- `1 <= descriptions.length <= 10^4`
- `descriptions[i].length == 3`
- `1 <= parent_i, child_i <= 10^5`
- `0 <= isLeft_i <= 1`
- The binary tree described by `descriptions` is valid.

---

### Approach 1: Hash Map and Single-Pass Construction {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def createBinaryTree1(descriptions: List[List[int]]) -> (
        Optional)[BinaryTreeNode]:
    """
    Constructs a binary tree from a list of node descriptions and returns its
    root.
    Time: O(n) where `n` is the number of descriptions (nodes), as we iterate
          through the list twice.
    Space: O(n) as we store each unique node in a map. In the worst case, we
           store all nodes.
    """
    # Create a map of child values to their corresponding nodes
    node_map = {child: BinaryTreeNode(child) for _, child, _ in descriptions}

    root = None
    for parent_value, child_value, is_left_child in descriptions:
        if parent_value not in node_map:
            # Create root node (the only parent value not present as a child)
            root = node_map[parent_value] = BinaryTreeNode(parent_value)

        # Assign child node to appropriate side of parent
        if is_left_child:
            node_map[parent_value].left = node_map[child_value]
        else:
            node_map[parent_value].right = node_map[child_value]

    return root
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a hash map (dictionary) to efficiently construct the binary tree in
a single pass through the descriptions.
This approach exploits the property that each node in a binary tree has a unique
value, allowing us to use these values as keys in our hash map.

- **Node Storage:** Each unique node is stored in a hash map, allowing $O(1)$ access when connecting parent-child
  relationships.
- **Root Identification:** The root is identified as the only parent node that doesn't appear as a child in any
  description.
- **Tree Construction:** The tree is built incrementally by processing each description and connecting nodes based on
  the given parent-child relationships.

> **Key Insight:**
> By using a hash map to store nodes, we can avoid multiple passes through the data and construct the tree efficiently.
> This approach also naturally handles the identification of the root node without requiring a separate step.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Initialization:**

   ```python
   # Create a map of child values to their corresponding nodes
   node_map = {child: BinaryTreeNode(child) for _, child, _ in descriptions}
   ```
   This line creates a dictionary `node_map` where each key is a child value from the descriptions, and the
   corresponding value is a new `BinaryTreeNode` with that value.
   This initializes all nodes that appear as children in the descriptions.

2. **Root Initialization and Tree Construction:**
   ```python
   root = None
   for parent_value, child_value, is_left_child in descriptions:
       if parent_value not in node_map:
           # Create root node (the only parent value not present as a child)
           root = node_map[parent_value] = BinaryTreeNode(parent_value)
   ```
   This loop iterates through each description.
   If a parent value is encountered that's not in the `node_map`, it means this node hasn't been seen as a child before,
   so it must be the root.
   We create this node and assign it to both `root` and `node_map[parent_value]`.

3. **Child Assignment:**
   ```python
   # Assign child node to appropriate side of parent
   if is_left_child:
       node_map[parent_value].left = node_map[child_value]
   else:
       node_map[parent_value].right = node_map[child_value]
   ```
   For each description, we assign the child node to either the left or right of the parent node based on
   the `is_left_child` value.
   Both parent and child nodes are accessed from the `node_map` in $O(1)$ time.

4. **Result Return:**

   ```python
   return root
   ```
   After processing all descriptions, we return the root node of the constructed binary tree.

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the number of descriptions (which is equal to the number of edges in the tree).
  We iterate through the descriptions once to create the `node_map`, and then again to construct the tree.
  Both operations are $O(n)$, resulting in a total time complexity of $O(n)$.

**Space Complexity:**

- $O(n)$, where $n$ is the number of descriptions.
  The `node_map` stores one entry for each unique node in the tree.
  In the worst case, this could be up to $n+1$ nodes ($n$ child nodes plus one root node that only appears as a parent).
  Therefore, the space complexity is $O(n)$.

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

**Input:**

```python
descriptions = [[52, 58, 0], [41, 39, 1], [52, 45, 1], 
                [41, 43, 0], [45, 41, 1], [60, 52, 1]]
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - The function starts by creating a `node_map` dictionary.
      This map uses child values as keys and `BinaryTreeNode`
      objects as values.
    - Initial `node_map`:

        | Child Value | Node               |
        |-------------|--------------------|
        | 58          | BinaryTreeNode(58) |
        | 39          | BinaryTreeNode(39) |
        | 45          | BinaryTreeNode(45) |
        | 43          | BinaryTreeNode(43) |
        | 41          | BinaryTreeNode(41) |
        | 52          | BinaryTreeNode(52) |

    - `root` is initialized as `None`.

2. **Main Algorithm Process:**
    - **Iteration 1:**
        - Processing `[52, 58, 0]`
        - `52` is in `node_map`, so no new node is created.
        - `58` is assigned as the right child of `52` because `is_left_child` is `0`.
        - Current tree: `52 -> 58 (right)`

    - **Iteration 2:**
        - Processing `[41, 39, 1]`
        - `41` is in `node_map`, so no new node is created.
        - `39` is assigned as the left child of `41` because `is_left_child` is `1`.
        - Current tree: `52 -> 58 (right)`, `41 -> 39 (left)`

    - **Iteration 3:**
        - Processing `[52, 45, 1]`
        - `52` already exists in `node_map`.
        - `45` is assigned as the left child of `52` (`is_left_child` is `1`).
        - Current tree: `52 -> 58 (right), 45 (left)`, `41 -> 39 (left)`

    - **Iteration 4:**
        - Processing `[41, 43, 0]`
        - `41` already exists in `node_map`.
        - `43` is assigned as the right child of `41` (`is_left_child` is `0`).
        - Current tree: `52 -> 58 (right), 45 (left)`, `41 -> 39 (left), 43 (right)`

    - **Iteration 5:**
        - Processing `[45, 41, 1]`
        - `45` already exists in `node_map`.
        - `41` is assigned as the left child of `45` (`is_left_child` is `1`).
        - Current tree: `52 -> 58 (right), 45 (left)`, `45 -> 41 (left)`, `41 -> 39 (left), 43 (right)`

    - **Iteration 6:**
        - Processing `[60, 52, 1]`
        - `60` is not in `node_map`, so a new `BinaryTreeNode(60)` is created and set as `root` because it is the only
          parent node not present as a child.
        - `52` is assigned as the left child of `60`.
        - Final tree: `60 -> 52 (left)`, `52 -> 58 (right), 45 (left)`, `45 -> 41 (left)`, `41 -> 39 (left), 43 (right)`

3. **Loop Termination:**
    - The loop terminates after processing all descriptions in the input list.
    - The final state of the tree is complete, with `60` as the root node.

4. **Visual Aid:**
   Here's a summary table of the iterations:

   | Iteration | Parent | Child | Child Position | Parent Node Status |
   |-----------|--------|-------|----------------|--------------------|
   | 1         | 52     | 58    | Right          | Existed            |
   | 2         | 41     | 39    | Left           | Existed            |
   | 3         | 52     | 45    | Left           | Existed            |
   | 4         | 41     | 43    | Right          | Existed            |
   | 5         | 45     | 41    | Left           | Existed            |
   | 6         | 60     | 52    | Left           | Created            |

5. **Result Calculation/Final Steps:**
    - After processing all descriptions, the function has constructed the entire binary tree.
    - The `root` variable holds the reference to the root node of the tree, which is `60`.
    - The function returns this `root` node, representing the entire constructed binary tree.

The final tree structure looks like this:

![july15-2024-ap1.png](july15-2024-ap1.png)

---

## July 16 -> 2. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d2_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_2" collapsible="true" default-state="expanded"}

...

---

## July 17 -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

## July 18 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

## July 19 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

## July 20 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

## July 21 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---
