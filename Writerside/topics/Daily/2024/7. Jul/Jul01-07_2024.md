# July 2024, Week 1: July 1st - July 7th

## July 1 -> 1550. Three Consecutive Odds {collapsible="true" default-state="collapsed"}

Given an integer `arr`, return `true` if there are three consecutive odd numbers in the array.
Otherwise, return `false`.

**Example 1:**

**Input:** arr = [2,6,4,1]
**Output:** false
**Explanation:** There are no three consecutive odds.

**Example 2:**

**Input:** arr = [1,2,34,3,4,5,7,23,12]
**Output:** true
**Explanation:** [5,7,23] are three consecutive odds.

**Constraints:**

- `1 <= arr.length <= 1000`
- `1 <= arr[i] <= 1000`

---

### Approach 1: Single-Pass Counter {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def threeConsecutiveOdds1(arr: List[int]) -> bool:
    """
    Determines if there are three consecutive odd numbers in the given array.

    This function iterates through the array once, keeping track of the count
    of consecutive odd numbers encountered. It uses a single variable
    'consecutive_odds' to maintain this count, resetting it to 0 whenever an
    even number is found. This approach is memory-efficient and allows for a
    single-pass solution.

    The time complexity of this solution is O(n), where `n` is the length of
    the input array, because it performs a single iteration through the array
    in the worst case. The space complexity is O(1) as it uses only a
    constant amount of extra space regardless of the input size.
    """
    if len(arr) < 3:
        return False
    
    consecutive_odds = 0
    for num in arr:
        if num % 2:
            consecutive_odds += 1
        else:
            consecutive_odds = 0
        if consecutive_odds == 3:
            return True
    return False
```

{collapsible="true" default-state="expanded" collapsed-title="Single-Pass Counter Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a single-pass iteration with a counter to efficiently detect three
consecutive odd numbers in the array.
This approach exploits the sequential nature of the problem and the binary property of numbers (odd or even).

- **Counter Reset Mechanism:** The solution uses a counter that increments for odd numbers and resets for even numbers,
  allowing it to track consecutive odd numbers efficiently.
- **Early Termination:** The algorithm returns `True` as soon as it detects three consecutive odd numbers, avoiding
  unnecessary iterations through the rest of the array.

> **Key Insight:**
> By using a single counter and resetting it when an even number is encountered, the algorithm can
> detect three consecutive odd numbers without needing to store or track individual numbers, leading to constant space
> complexity.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Input Validation:**
   ```python
   if len(arr) < 3:
       return False
   ```
   This check ensures that the array has at least three elements.
   If not, it's impossible to have three consecutive odd numbers, so we return `False` immediately.
   This optimization prevents unnecessary processing for small arrays.

2. **Counter Initialization:**
   ```python
   consecutive_odds = 0
   ```
   We initialize a counter `consecutive_odds` to keep track of the number of consecutive odd integers encountered.
   This single variable is key to the algorithm's space efficiency.

3. **Array Iteration and Odd Number Detection:**
   ```python
   for num in arr:
       if num % 2:
           consecutive_odds += 1
       else:
           consecutive_odds = 0
   ```
   We iterate through each number in the array.
   The modulo operation `num % 2` checks if a number is odd (remainder 1 when divided by 2).
   If it's odd, we increment the counter.
   If it's even, we reset the counter to 0.
   This reset is crucial as it ensures we're only counting consecutive odd numbers.

4. **Consecutive Odd Check and Early Return:**
   ```python
   if consecutive_odds == 3:
       return True
   ```
   After each update to `consecutive_odds`, we check if it has reached 3. If so, we've found three consecutive odd
   numbers, and we can immediately return `True`.
   This early return optimizes the function by avoiding unnecessary iterations once the condition is met.

5. **Final Return:**
   ```python
   return False
   ```
   If we've iterated through the entire array without finding three consecutive odd numbers, we return `False`.

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the length of the input array `arr`.
  This is because in the worst case, we need to iterate through all elements of the array once.
  Each operation inside the loop (modulo, increment, comparison) takes constant
  time, so the overall time complexity is linear with respect to the array length.

**Space Complexity:**

- $O(1)$, or constant space.
  This is because we only use a single integer variable `consecutive_odds` regardless of the input size.
  The space used does not grow with the size of the input array, making this solution very memory-efficient.

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

**Input:**

```python
arr = [1, 2, 34, 3, 4, 5, 7, 23, 12]
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - The function `threeConsecutiveOdds1` is called with the input array `[1, 2, 34, 3, 4, 5, 7, 23, 12]`.
    - The variable `consecutive_odds` is initialized to 0.
      This variable will keep track of the count of consecutive odd numbers encountered.

2. **Input Validation:**
    - The function checks if the length of the input array is less than 3.
    - In this case, the array length is 9, which is valid (greater than or equal to 3), so the function proceeds.

3. **Main Loop:**

    - **Iteration 1:**
        - Current number: 1
        - 1 is odd (1 % 2 = 1), so `consecutive_odds` is incremented to 1.
        - 1 < 3, so the function continues to the next iteration.

    - **Iteration 2:**
        - Current number: 2
        - 2 is even (2 % 2 = 0), so `consecutive_odds` is reset to 0.

    - **Iteration 3:**
        - Current number: 34
        - 34 is even (34 % 2 = 0), so `consecutive_odds` remains 0.

    - **Iteration 4:**
        - Current number: 3
        - 3 is odd (3 % 2 = 1), so `consecutive_odds` is incremented to 1.

    - **Iteration 5:**
        - Current number: 4
        - 4 is even (4 % 2 = 0), so `consecutive_odds` is reset to 0.

    - **Iteration 6:**
        - Current number: 5
        - 5 is odd (5 % 2 = 1), so `consecutive_odds` is incremented to 1.

    - **Iteration 7:**
        - Current number: 7
        - 7 is odd (7 % 2 = 1), so `consecutive_odds` is incremented to 2.

    - **Iteration 8:**
        - Current number: 23
        - 23 is odd (23 % 2 = 1), so `consecutive_odds` is incremented to 3.
        - At this point, `consecutive_odds` equals 3, so the function immediately returns `True`.

4. **Visual Aid:**
    - The iteration summary table shows the progression of the `consecutive_odds` count for each element in the array.
        
    | Element | Number | Odd/Even | Consecutive Odds |
    |---------|--------|----------|------------------|
    | 1       | 1      | Odd      | 1                |
    | 2       | 2      | Even     | 0                |
    | 3       | 34     | Even     | 0                |
    | 4       | 3      | Odd      | 1                |
    | 5       | 4      | Even     | 0                |
    | 6       | 5      | Odd      | 1                |
    | 7       | 7      | Odd      | 2                |
    | 8       | 23     | Odd      | 3                |

5. **Result Calculation/Final Steps:**
    - The function returns `True` as soon as it encounters three consecutive odd numbers (5, 7, 23).
    - The last element (12) is not processed because the function has already found the desired pattern and returned.

---

## July 2 -> 2. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d2_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_2" collapsible="true" default-state="expanded"}

...

---

## July 3 -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

## July 4 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

## July 5 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

## July 6 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

## July 7 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---
