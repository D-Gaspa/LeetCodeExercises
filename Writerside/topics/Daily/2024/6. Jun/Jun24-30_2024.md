# June 2024, Week 5: June 24th - June 30th

## June 24 -> 995. Minimum Number of K Consecutive Bit Flips {collapsible="true" default-state="collapsed"}

You are given a binary array `nums` and an integer `k`.

A **k-bit flip** is choosing a **subarray** of length `k` from `nums` and simultaneously changing every `0` in the
subarray to `1`, and every `1` in the subarray to `0`.

Return *the minimum number of **k-bit flips** required so that there is no* `0` *in the array*.
If it is not possible, return `-1`.

A **subarray** is a **contiguous** part of an array.

**Example 1:**

- **Input:** nums = [0,1,0], k = 1
- **Output:** 2
- **Explanation:** Flip nums[0], then flip nums[2].

**Example 2:**

- **Input:** nums = [1,1,0], k = 2
- **Output:** -1
- **Explanation:** No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].

**Example 3:**

- **Input:** nums = [0,0,0,1,0,1,1,0], k = 3
- **Output:** 3
- **Explanation:**
    - Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
    - Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
    - Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]

**Constraints:**

- `1 <= nums.length <= 10^5`
- `1 <= k <= nums.length`

---

### Approach 1: Sliding Window with Deque {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def minKBitFlips1(nums: List[int], k: int) -> int:
    """
    Determines the minimum number of k-bit flips required to convert all
    elements in `nums` to 1.

    This function uses a sliding window approach with a deque to efficiently
    track the flips. It maintains a 'current_flipped_state' to represent the
    cumulative effect of flips on the current element, avoiding the need to
    actually modify the input array. The algorithm iterates through the array
    once, deciding whether to flip at each position based on the current
    state and the original value. This approach allows for efficient handling
    of overlapping flips without the need to recalculate previous operations.

    The time complexity of this solution is O(n), where `n` is the length of
    `nums`, because it processes each element once with constant-time
    operations. The space complexity is O(k) due to the deque storing at most
    `k` elements to track the sliding window of flips.
    """
    if k == 1:
        return nums.count(0)  # Optimization for k=1 case

    flip_window_deque = deque()
    current_flipped_state = 0
    total_flips = 0

    for index, num in enumerate(nums):
        if index >= k:
            # Remove the effect of the flip that's now out of the window
            current_flipped_state ^= flip_window_deque.popleft()

        if current_flipped_state == num:
            # The current state matches the original value, so a flip is
            # needed
            if index + k > len(nums):
                return -1  # Not enough elements left for a flip
            flip_window_deque.append(1)
            current_flipped_state ^= 1
            total_flips += 1
        else:
            flip_window_deque.append(0)  # No flip needed at this position

    return total_flips
```

{collapsible="true" default-state="expanded" collapsed-title="Sliding Window with Deque Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a sliding window approach with a deque to efficiently track k-bit
flips across the array.
This method allows for optimized handling of overlapping flips without modifying the original array.

- **Sliding Window:** A window of size `k` is used to manage the effect of flips on each element.
- **Deque for Flip Tracking:** A deque efficiently tracks whether a flip occurred at each position within the current
  window.
- **Current Flipped State:** This variable represents the cumulative effect of all flips on the current element.
- **Virtual Flips:** Instead of actually modifying the array, the algorithm virtually flips elements by tracking the
  flip state.

> **Key Insight:**
> The solution avoids the need to recalculate previous operations by maintaining a running state of
> flips, allowing for $O(n)$ time complexity despite potentially overlapping flip operations.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Initialization and Edge Case Handling:**
   ```python
   if k == 1:
       return nums.count(0)
   
   flip_window_deque = deque()
   current_flipped_state = 0
   total_flips = 0
   ```
   The function starts with an optimization for `k=1`, simply counting the zeros.
   It then initializes the deque, the current flipped state, and the total flip count.

2. **Main Loop - Iterating Through the Array:**
   ```python
   for index, num in enumerate(nums):
   ```
   This loop processes each element of the array, deciding whether to flip at each position.

3. **Managing the Sliding Window:**
   ```python
   if index >= k:
       current_flipped_state ^= flip_window_deque.popleft()
   ```
   When the window size exceeds `k`, the effect of the oldest flip is removed using XOR operation.

4. **Flip Decision and Execution:**
   ```python
   if current_flipped_state == num:
       if index + k > len(nums):
           return -1
       flip_window_deque.append(1)
       current_flipped_state ^= 1
       total_flips += 1
   else:
       flip_window_deque.append(0)
   ```
   If the current state matches the original value, a flip is needed.
   The function checks if there's enough space for a flip, updates the deque and state, and increments the flip count.
   If no flip is needed, it appends 0 to the deque.

5. **Result Calculation/Return:**
   ```python
   return total_flips
   ```
   After processing all elements, the function returns the total number of flips performed.

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the length of the input array `nums`.
  This is because the algorithm processes each element of the array exactly once,
  performing constant-time operations for each element.

**Space Complexity:**

- $O(k)$, where $k$ is the flip window size.
  This is due to the deque storing at most $k$ elements to track the sliding window of flips.
  The space used is independent of the input array size $n$, making it more efficient for large arrays
  with smaller $k$ values.

---

### Approach 2: In-place Tracking with Active Flips {id="approach_d1_3" collapsible="true" default-state="expanded"}

```Python
def minKBitFlips3(nums: List[int], k: int) -> int:
    """
    Computes the minimum number of k-bit flips needed to convert all
    elements in `nums` to 1.

    This function uses a clever in-place marking technique to track flips
    efficiently. It uses the value 2 to mark the start of a flip in the
    original array, allowing it to implicitly store flip information without
    additional data structures. The 'active_flips' variable keeps track of
    the number of active flips affecting the current element, enabling quick
    decisions on whether to flip. This approach combines the benefits of
    in-place modification with efficient flip tracking.

    The time complexity of this solution is O(n), where `n` is the length of
    `nums`, as it processes each element once with constant-time operations.
    The space complexity is O(1) since it modifies the input array in-place
    and uses only a constant amount of extra space.
    """
    if k == 1:
        return nums.count(0)  # Optimization for k=1 case

    n = len(nums)
    active_flips = 0
    total_flips = 0

    for index in range(n):
        if index >= k and nums[index - k] == 2:
            # A flip that started k positions ago is ending
            active_flips -= 1

        if (active_flips % 2) == nums[index]:
            # Current element needs to be flipped
            if index + k > n:
                return -1  # Not enough elements left for a flip
            nums[index] = 2  # Mark the start of a new flip
            active_flips += 1
            total_flips += 1

    return total_flips
```

{collapsible="true" default-state="expanded" collapsed-title="In-place Tracking with Active Flips Code..."}

#### Understanding the Core Idea {id="core-idea_d1_2" collapsible="true" default-state="expanded"}

The central concept of this solution is to use an in-place marking technique with clever bit manipulation to efficiently
track k-bit flips across the array.
This method combines the space efficiency of in-place modifications with an optimized approach
to handling overlapping flips.

- **In-place Marking:** The algorithm uses the value 2 to mark the start of a flip in the original array, enabling
  implicit storage of flip information without additional data structures.
- **Active Flips Tracking:** An `active_flips` variable keeps count of the number of active flips affecting the current
  element, allowing for quick flip decisions.
- **Parity-based Flip Detection:** The algorithm uses the parity of `active_flips` to determine whether the current
  element needs to be flipped.
- **Virtual Flips:** Instead of actually performing k-bit flips, the algorithm simulates their effect by tracking flip
  starts and active flip count.

> **Key Insight:**
> By using the value 2 as a flip marker and tracking active flips, the solution achieves $O(1)$ space
> complexity while efficiently handling overlapping flips, combining the benefits of previous approaches.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_2" collapsible="true" default-state="expanded"}

1. **Initialization and Edge Case Handling:**
   ```python
   if k == 1:
       return nums.count(0)
   
   n = len(nums)
   active_flips = 0
   total_flips = 0
   ```
   The function starts with an optimization for `k=1`, simply counting the zeros.
   It then initializes the length of the array, active flips count, and total flips count.

2. **Main Loop - Linear Scan:**
   ```python
   for index in range(n):
   ```
   This loop processes each element of the array, making flip decisions based on the current state and previous flips.

3. **Managing Active Flips:**
   ```python
   if index >= k and nums[index - k] == 2:
       active_flips -= 1
   ```

4. **Flip Decision and Execution:**
   ```python
   if (active_flips % 2) == nums[index]:
       if index + k > n:
           return -1
       nums[index] = 2
       active_flips += 1
       total_flips += 1
   ```
   If the parity of active flips matches the current element's value, a flip is needed.
   The function checks if there's enough space for a flip,
   marks the flip start with 2, and updates the active and total flip counts.

5. **Result Calculation/Return:**
   ```python
   return total_flips
   ```
   After processing all elements, the function returns the total number of flips performed.

> **Note:**
> While this approach does modify the input array during processing, it's possible to restore the original values.
> By subtracting 2 from `nums[i - k]` after decrementing `active_flips`,
> we can revert each modified element to its original state.
> This makes the modification temporary and allows us to preserve the input array if needed.
>
{style="tip"}


---

#### Example {id="example_d1_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d1_2" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where n is the length of the input array `nums`.
  This is because the algorithm processes each element of the array exactly once in the main loop,
  performing constant-time operations for each element.

**Space Complexity:**

- $O(1)$, as the algorithm uses only a constant amount of extra space regardless of the input size.
  It cleverly uses the input array itself to store flip information by marking flip starts with the value 2,
  avoiding the need for additional data structures that grow with the input size.

---

## June 25 -> 2. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d2_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_2" collapsible="true" default-state="expanded"}

...

---

## June 26 -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

## June 27 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

## June 28 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

## June 29 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

## June 30 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---
