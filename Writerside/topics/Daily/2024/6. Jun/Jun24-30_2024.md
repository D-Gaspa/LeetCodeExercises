# June 2024, Week 5: June 24th - June 30th

## June 24 -> 995. Minimum Number of K Consecutive Bit Flips {collapsible="true" default-state="collapsed"}

You are given a binary array `nums` and an integer `k`.

A **k-bit flip** is choosing a **subarray** of length `k` from `nums` and simultaneously changing every `0` in the
subarray to `1`, and every `1` in the subarray to `0`.

Return *the minimum number of **k-bit flips** required so that there is no* `0` *in the array*.
If it is not possible, return `-1`.

A **subarray** is a **contiguous** part of an array.

**Example 1:**

- **Input:** nums = [0,1,0], k = 1
- **Output:** 2
- **Explanation:** Flip nums[0], then flip nums[2].

**Example 2:**

- **Input:** nums = [1,1,0], k = 2
- **Output:** -1
- **Explanation:** No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].

**Example 3:**

- **Input:** nums = [0,0,0,1,0,1,1,0], k = 3
- **Output:** 3
- **Explanation:**
    - Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]
    - Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]
    - Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]

**Constraints:**

- `1 <= nums.length <= 10^5`
- `1 <= k <= nums.length`

---

### Approach 1: Sliding Window with Deque {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def minKBitFlips1(nums: List[int], k: int) -> int:
    """
    Determines the minimum number of k-bit flips required to convert all
    elements in `nums` to 1.

    This function uses a sliding window approach with a deque to efficiently
    track the flips. It maintains a 'current_flipped_state' to represent the
    cumulative effect of flips on the current element, avoiding the need to
    actually modify the input array. The algorithm iterates through the array
    once, deciding whether to flip at each position based on the current
    state and the original value. This approach allows for efficient handling
    of overlapping flips without the need to recalculate previous operations.

    The time complexity of this solution is O(n), where `n` is the length of
    `nums`, because it processes each element once with constant-time
    operations. The space complexity is O(k) due to the deque storing at most
    `k` elements to track the sliding window of flips.
    """
    if k == 1:
        return nums.count(0)  # Optimization for k=1 case

    flip_window_deque = deque()
    current_flipped_state = 0
    total_flips = 0

    for index, num in enumerate(nums):
        if index >= k:
            # Remove the effect of the flip that's now out of the window
            current_flipped_state ^= flip_window_deque.popleft()

        if current_flipped_state == num:
            # The current state matches the original value, so a flip is
            # needed
            if index + k > len(nums):
                return -1  # Not enough elements left for a flip
            flip_window_deque.append(1)
            current_flipped_state ^= 1
            total_flips += 1
        else:
            flip_window_deque.append(0)  # No flip needed at this position

    return total_flips
```

{collapsible="true" default-state="expanded" collapsed-title="Sliding Window with Deque Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Forward Propagation with Expected State {id="approach_d1_2" collapsible="true" default-state="expanded"}

```Python
def minKBitFlips2(nums: List[int], k: int) -> int:
    """
    Calculates the minimum number of k-bit flips required to convert all
    elements in `nums` to 1.

    This function uses a linear scan approach with in-place modifications
    to track flips. It maintains an 'expected_state' variable to determine
    whether a flip is needed at each position. The algorithm cleverly uses
    the original array to implicitly store flip information by toggling
    values, eliminating the need for additional data structures. This method
    reduces space complexity at the cost of modifying the input array.

    The time complexity of this solution is O(n), where `n` is the length of
    `nums`, as it processes each element once with constant-time operations.
    The space complexity is O(1) since it only uses a constant amount of
    extra space regardless of input size.
    """
    if k == 1:
        return nums.count(0)  # Optimization for k=1 case

    flip_count = 0
    expected_state = 1  # We expect all elements to be 1 eventually

    for index in range(k, len(nums)):
        if nums[index - k] != expected_state:
            # A flip was performed k positions ago
            expected_state = 1 - expected_state
            flip_count += 1

        if expected_state == 0:
            # Simulate the effect of a flip on the current element
            nums[index] = 1 - nums[index]

    # Check if the last k elements are all the same
    last_value = nums[-1]
    if not all(num == last_value for num in nums[-k:]):
        return -1  # Impossible to make all elements 1

    # Account for a possible final flip if needed
    return flip_count + (1 if last_value != expected_state else 0)
```

{collapsible="true" default-state="expanded" collapsed-title="Forward Propagation with Expected State Code..."}

#### Understanding the Core Idea {id="core-idea_d1_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d1_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d1_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d1_2" collapsible="true" default-state="expanded"}

...

---

### Approach 3: In-place Tracking with Active Flips {id="approach_d1_3" collapsible="true" default-state="expanded"}

```Python
def minKBitFlips3(nums: List[int], k: int) -> int:
    """
    Computes the minimum number of k-bit flips needed to convert all
    elements in `nums` to 1.

    This function uses a clever in-place marking technique to track flips
    efficiently. It uses the value 2 to mark the start of a flip in the
    original array, allowing it to implicitly store flip information without
    additional data structures. The 'active_flips' variable keeps track of
    the number of active flips affecting the current element, enabling quick
    decisions on whether to flip. This approach combines the benefits of
    in-place modification with efficient flip tracking.

    The time complexity of this solution is O(n), where `n` is the length of
    `nums`, as it processes each element once with constant-time operations.
    The space complexity is O(1) since it modifies the input array in-place
    and uses only a constant amount of extra space.
    """
    if k == 1:
        return nums.count(0)  # Optimization for k=1 case

    n = len(nums)
    active_flips = 0
    total_flips = 0

    for index in range(n):
        if index >= k and nums[index - k] == 2:
            # A flip that started k positions ago is ending
            active_flips -= 1

        if (active_flips % 2) == nums[index]:
            # Current element needs to be flipped
            if index + k > n:
                return -1  # Not enough elements left for a flip
            nums[index] = 2  # Mark the start of a new flip
            active_flips += 1
            total_flips += 1

    return total_flips
```

{collapsible="true" default-state="expanded" collapsed-title="In-place Tracking with Active Flips Code..."}

#### Understanding the Core Idea {id="core-idea_d1_3" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d1_3" collapsible="true" default-state="expanded"}

...

While this approach does modify the input array during processing, it's possible to restore the original values.
By subtracting 2 from `nums[i - k]` after decrementing `active_flips`,
we can revert each modified element to its original state.
This makes the modification temporary and allows us to preserve the input array if needed.

---

#### Example {id="example_d1_3" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d1_3" collapsible="true" default-state="expanded"}

...

---

## June 25 -> 2. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d2_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_2" collapsible="true" default-state="expanded"}

...

---

## June 26 -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

## June 27 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

## June 28 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

## June 29 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

## June 30 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---
