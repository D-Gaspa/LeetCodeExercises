# June 2024, Week 2: June 3rd - June 9th

## June 3 -> 2486. Append Characters to String to Make Subsequence {collapsible="true" default-state="collapsed"}

You are given two strings `s` and `t` consisting of only lowercase English letters.

Return *the minimum number of characters that need to be appended to the end of* `s` *so that* `t` *becomes
a **subsequence** of* `s`.

A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing
the order of the remaining characters.

**Example 1:**

- **Input:** `s = "coaching"`, `t = "coding"`
- **Output:** 4
- **Explanation:** Append the characters "ding" to the end of `s` so that `s = "coachingding"`.
  Now, `t` is a subsequence of `s` (`"coachingding"`).
  It can be shown that appending any three characters to the end of `s` will never make `t` a subsequence.

**Example 2:**

- **Input:** `s = "abcde"`, `t = "a"`
- **Output:** 0
- **Explanation:** `t` is already a subsequence of `s` (`"abcde"`).

**Example 3:**

- **Input:** `s = "z"`, `t = "abcde"`
- **Output:** 5
- **Explanation:** Append the characters `"abcde"` to the end of `s` so that `s = "zabcde"`.
  Now, `t` is a subsequence of `s` (`"zabcde"`).
  It can be shown that appending any four characters to the end of `s` will never make `t` a subsequence.

**Constraints:**

- `1 <= s.length, t.length <= 105`
- `s` and `t` consist only of lowercase English letters.

---

### Approach 1: Two Pointer Technique {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def appendCharacters1(s: str, t: str) -> int:
    """
    Calculates the minimum number of characters from string 't' 
    that must be appended to string 's' to make 't' a subsequence of 's'.

    This function iterates through both strings, comparing characters at
    corresponding positions.  When a match is found, it advances in both
    strings; otherwise, it only moves forward in the first string. The
    result is the number of characters remaining in 't' after the comparison,
    indicating how many need to be appended.

    The function operates in O(n) time complexity, where 'n' is the length of
    the longer string since each character of the string 's' and 't' is
    visited at most once. The space complexity is O(1) as the solution here
    does not require additional space that scales with input size.
    """
    s_index = 0
    t_index = 0

    s_length = len(s)
    t_length = len(t)

    while s_index < s_length and t_index < t_length:
        if s[s_index] == t[t_index]:
            t_index += 1
        s_index += 1

    # Return the count of remaining characters in 't' that needs to be
    # appended to 's'
    return t_length - t_index
```
{collapsible="true" default-state="expanded" collapsed-title="Two Pointer Technique Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a two-pointer technique to efficiently compare and traverse both
strings simultaneously.
This approach allows us to determine how much of string `t` is already a subsequence of `s`, and
consequently, how many characters from `t` need to be appended to `s`.

- **Subsequence Matching:** The solution exploits the fact that we only need to find characters of `t` in `s` in the
  same order, not necessarily consecutively.
- **Efficient Traversal:** By using two pointers, we can avoid unnecessary comparisons and achieve linear time
  complexity.

> **Key Insight:**
> The number of characters to append is simply the number of characters in `t` that weren't matched in `s`,
> which can be calculated as the difference between the length of `t` and the final position of the `t` pointer.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   s_index = 0
   t_index = 0

   s_length = len(s)
   t_length = len(t)
   ```
   We initialize two pointers, `s_index` and `t_index`, to keep track of our current positions in strings `s` and `t`
   respectively.
   We also store the lengths of both strings for easier access and improved readability.

2. **Main Comparison Loop:**
   ```python
   while s_index < s_length and t_index < t_length:
       if s[s_index] == t[t_index]:
           t_index += 1
       s_index += 1
   ```
   This is the core of the algorithm. We iterate through both strings simultaneously:
    - If the characters at the current positions match, we move forward in both strings (incrementing both `s_index`
      and `t_index`).
    - If they don't match, we only move forward in `s` (incrementing only `s_index`).
    - The loop continues until we reach the end of either string.

   This approach ensures that we find the longest subsequence of `t` that exists in `s`.

3. **Result Calculation:**
   ```python
   return t_length - t_index
   ```
   After the loop, `t_index` represents how many characters of `t` we successfully matched in `s`.
   Therefore, `t_length - t_index` gives us the number of remaining characters in `t` that need to be appended to `s`.

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the length of the longer string between `s` and `t`.
  This is because we iterate through each character of `s` at most once, and each character of `t` at most once.
  The worst-case scenario occurs when `s` and `t` have no matching characters,
  causing us to traverse the entire length of `s`.

**Space Complexity:**

- $O(1)$, or constant space. The algorithm uses a fixed number of
  variables (`s_index`, `t_index`, `s_length`, `t_length`) regardless of the input size. It doesn't require any
  additional data structures that grow with the input size.

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

**Input:** `s = "coaching"`, `t = "coding"`

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - `s_index` (pointer for `s`) is set to 0.
    - `t_index` (pointer for `t`) is set to 0.
    - `s_length` is calculated as 8 (length of "coaching").
    - `t_length` is calculated as 6 (length of "coding").

2. **Main Loop (Comparing 's' and 't'):**
    - **Iteration 1:**
        - **Comparison:** `s[0]` ('c') matches `t[0]` ('c').
        - **Action:**  Both `s_index` and `t_index` are incremented to 1.

    - **Iteration 2:**
        - **Comparison:** `s[1]` ('o') matches `t[1]` ('o').
        - **Action:** Both `s_index` and `t_index` are incremented to 2.

    - **Iterations 3 - 8:**
        - **Comparison:** In each iteration, `s[s_index]` does not match `t[t_index]` ('d').
        - **Action:** Only `s_index` is incremented.
        - **Note:** We're essentially skipping over characters in `s` ("aching") that are not part of the subsequence
          we're looking for ("coding").

3. **Loop Termination:**
    - The loop terminates because `s_index` reaches 8 (end of `s`).
    - At this point, `t_index` is still at 2.

4. **Iteration Summary:**

    | `s_index` | `t_index` | `s[s_index]` | `t[t_index]` | Match? |
    |-----------|-----------|--------------|--------------|--------|
    | 0         | 0         | c            | c            | Yes    |
    | 1         | 1         | o            | o            | Yes    |
    | 2         | 2         | a            | d            | No     |
    | 3         | 2         | c            | d            | No     |
    | 4         | 2         | h            | d            | No     |
    | 5         | 2         | i            | d            | No     |
    | 6         | 2         | n            | d            | No     |
    | 7         | 2         | g            | d            | No     |

5. **Result Calculation:**
    - `t_length - t_index` = 6 - 2 = 4.
    - This indicates that `4` characters ("ding") need to be appended to `s` to make `t` a subsequence.

---

## June 4 -> 409. Longest Palindrome {collapsible="true" default-state="collapsed"}

Given a string `s` which consists of lowercase or uppercase letters, return the length of the **longest palindrome**
that can be built with those letters.

Letters are **case-sensitive**, for example, `"Aa"` is not considered a palindrome.

**Example 1:**

- **Input:** `s = "abccccdd"`
- **Output:** 7
- **Explanation:** One longest palindrome that can be built is `"dccaccd"`, whose length is 7.

**Example 2:**

- **Input:** `s = "a"`
- **Output:** 1
- **Explanation:** The longest palindrome that can be built is `a`, whose length is 1.

**Constraints:**

- `1 <= s.length <= 2000`
- `s` consists of lowercase **and/or** uppercase English letters only.

---

### Approach 1: Frequency Counting with Dictionary {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
def longestPalindrome1(s: str) -> int:
    """
    Calculates the length of the longest palindrome that can be built with
    the characters in the input string 's'.

    First, the function counts the frequency of each character using a
    defaultdict 'char_count'. Then, it iterates through the counts and if
    the count is even, it adds the count to the result. If the count is odd,
    it adds one less than the count to the result and sets 'odd_exists' flag
    to True. This is done because palindromes can have at most one character
    with an odd count (at the center of the palindrome); all other characters
    must occur an even number of times. Finally, if there was at least one
    character with an odd count, it adds 1 to the result, accounting for the
    possible center element in the palindrome.

    The time complexity of this function is O(n), where 'n' is the length of
    the input string 's'. This is because the function iterates over the
    string 's' once to count characters and iterates over every character
    frequency in 'char_count' once. The space complexity of this function is
    O(1) because the 'char_count' dictionary will at most contain entries
    equal to the number of different characters which are constant.
    """
    char_count = defaultdict(int)

    for char in s:
        char_count[char] += 1

    result = 0
    odd_exists = False

    for _, count in char_count.items():
        if count % 2 == 0:
            result += count
        else:
            result += count - 1
            odd_exists = True

    # If there was at least one character with an odd count, it can be used
    # as the center of the palindrome
    if odd_exists:
        result += 1

    return result
```

{collapsible="true" default-state="expanded" collapsed-title="Frequency Counting with Dictionary Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

The central concept of this solution is to leverage a frequency counting technique using a dictionary to determine the
maximum length of a palindrome that can be constructed from the given string.
This approach exploits two key properties of palindromes:

- **Even-count Characters:** Characters that appear an even number of times can be fully used in a palindrome, with
  half on each side.
- **Odd-count Characters:** For characters that appear an odd number of times, we can use all but one occurrence in
  pairs, and potentially use one leftover character as the center of the palindrome.

> **Key Insight:** The solution cleverly handles odd-count characters by subtracting 1 from their count and flagging
> that an odd count exists.
> This allows for the inclusion of one odd-count character as the center of the palindrome if needed.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   char_count = defaultdict(int)
   ```
   We initialize a `defaultdict` to store the frequency of each character.
   Using `defaultdict(int)` allows us to increment counts without explicitly checking if a key exists.

2. **Character Counting:**
   ```python
   for char in s:
       char_count[char] += 1
   ```
   This loop iterates through each character in the input string `s`, incrementing its count in the `char_count`
   dictionary.

3. **Palindrome Length Calculation:**
   ```python
   result = 0
   odd_exists = False

   for _, count in char_count.items():
       if count % 2 == 0:
           result += count
       else:
           result += count - 1
           odd_exists = True
   ```
   Here, we iterate through the character counts:
    - For even counts, we add the full count to the result.
    - For odd counts, we add one less than the count (making it even) and set `odd_exists` to `True`.

4. **Handling Center Character:**
   ```python
   if odd_exists:
       result += 1
   ```
   If we encountered any odd-count characters, we can use one as the center of the palindrome, so we add 1 to the
   result.

5. **Return Result:**
   ```python
   return result
   ```
   The function returns the calculated length of the longest possible palindrome.

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the length of the input string `s`.
  This is because we iterate through the string once to count characters, and then iterate through the character counts.
  Since there's a fixed number of possible characters, the second iteration is bounded by a constant.

**Space Complexity:**

- $O(1)$, because the `char_count` dictionary will contain at most 52 entries (26 lowercase and 26 uppercase letters),
  which is a constant regardless of the input size.

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

**Input:**
```Python
s = "abccccdd"
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - `char_count` is initialized as a defaultdict: `char_count = defaultdict(int)`
    - `result` is initialized to 0: `result = 0`
    - `odd_exists` is initialized to False: `odd_exists = False`

2. **Character Frequency Counting:**
    - The loop iterates through each character in the string `s = "abccccdd"`.
    - `char_count` is updated as follows:
        - `{'a': 1}` (after processing 'a')
        - `{'a': 1, 'b': 1}` (after processing 'b')
        - `{'a': 1, 'b': 1, 'c': 1}` ... and so on until:
        - `{'a': 1, 'b': 1, 'c': 4, 'd': 2}` (after processing all characters)

3. **Palindrome Length Calculation:**
    - The loop iterates over the `char_count` dictionary:
        - `'a'`: Count is 1 (odd), so 0 is added to `result` (result remains 0), and `odd_exists` is set to `True`.
        - `'b'`: Count is 1 (odd), so 0 is added to `result` (result remains 0), and `odd_exists` remains `True`.
        - `'c'`: Count is 4 (even), so 4 is added to `result` (result becomes 4).
        - `'d'`: Count is 2 (even), so 2 is added to `result` (result becomes 6).

4. **Center Character Adjustment:**
    - Since `odd_exists` is `True` (we found odd-frequency characters), 1 is added to `result`. The final `result` is 7.

5. **Result Calculation/Return:**
    - The function returns the final value of `result`, which is 7. This indicates that the longest possible palindrome
      we can construct from the letters in `"abccccdd"` has a length of 7 (e.g., `"dccaccd"`).

---

### Approach 2:Set-based Character Pairing {id="approach_d2_2" collapsible="true" default-state="expanded"}

```Python
def longestPalindrome2(s: str) -> int:
    """
    Calculates the length of the longest palindrome that can be built with
    the characters in the input string 's'.

    This function uses a set `character_set` to keep track of characters
    encountered. For each character, if it is already in the set, it can be
    paired with its existing counterpart, contributing 2 to the palindrome
    length. If not in the set, it is added to the set as it may be paired
    with a future character. In the end, if `character_set` still contains
    characters, it means a palindrome can still fit one more character in
    its middle. Therefore, the result is incremented by 1 if `character_set`
    is not empty.

    The time complexity is O(n), where `n` is the length of the input string
    due to the single pass through the string. The space complexity is O(1)
    since the set will contain at most 52 characters (26 lowercase and 26
    uppercase).
    """
    character_set = set()
    result = 0

    for char in s:
        if char in character_set:
            result += 2
            character_set.remove(char)
        else:
            character_set.add(char)

    # If there are characters left in the set, one of them can be used as the
    # center of the palindrome
    if character_set:
        result += 1

    return result
```

{collapsible="true" default-state="expanded" collapsed-title="Set-based Character Pairing Code..."}

#### Understanding the Core Idea {id="core-idea_d2_2" collapsible="true" default-state="expanded"}

The central concept of this solution is to use a set data structure to efficiently pair up characters for forming a
palindrome.
This approach leverages the following key ideas:

- **Character Pairing:** Each time we encounter a character that's already in the set, we can form a pair, contributing
  2 to the palindrome length.
- **Unpaired Characters:** Characters that don't find a pair remain in the set, and one of them can potentially be used
  as the center of the palindrome.

> **Key Insight:**
> By using a set, we can achieve $O(1)$ lookup and removal operations, making the pairing process very
> efficient.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d2_2" collapsible="true" default-state="expanded"}

1. **Initialization:**
   ```python
   character_set = set()
   result = 0
   ```
   We initialize an empty set to keep track of unpaired characters and a variable to store the palindrome length.

2. **Character Pairing Process:**
   ```python
   for char in s:
       if char in character_set:
           result += 2
           character_set.remove(char)
       else:
           character_set.add(char)
   ```
   This loop iterates through each character in the input string `s`:
    - If the character is already in the set, we've found a pair.
      We increment `result` by 2 and remove the character from the set.
    - If the character is not in the set, we add it to the set as a potential future pair.

3. **Handling Center Character:**
   ```python
   if character_set:
       result += 1
   ```
   After processing all characters, if the set is not empty, it means we have unpaired characters.
   We can use one of these as the center of the palindrome, so we add 1 to the result.

4. **Return Result:**
   ```python
   return result
   ```
   The function returns the calculated length of the longest possible palindrome.

---

#### Complexity Analysis {id="complexity-analysis_d2_2" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(n)$, where $n$ is the length of the input string `s`.
  We iterate through the string once, performing $O(1)$ operations (set lookup, addition, and removal)
  for each character.

**Space Complexity:**

- $O(1)$, because the `character_set` will contain at most 52 unique characters (26 lowercase and 26 uppercase letters),
  which is a constant regardless of the input size.

---

#### Example {id="example_d2_2" collapsible="true" default-state="expanded"}

**Input:**
```Python
s = "abccccdd"
```

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - An empty set `character_set` is created.
    - `result` is set to 0: `result = 0`

2. **Character Processing Loop:**
    - Iteration 1: The character 'a' is not in `character_set`, so it's added to the set.
    - Iteration 2: The character 'b' is not in `character_set`, so it's added to the set.
    - Iteration 3 & 4: The character 'c' is first added to the set.
      In the next iteration, 'c' is found in the set, so it's removed, and `result` is incremented by 2.
    - Iteration 5 & 6: The character 'c' is again added and then removed from the set, incrementing `result` by 2 again.
    - Iteration 7 & 8: The character 'd' follows the same add-remove pattern as 'c,' increasing `result` by another 2.

3. **Iteration Summary (Palindrome Length Calculation):**
        
    | Iteration | Character | Action                  | Character Set   | Result |
    |-----------|-----------|-------------------------|-----------------|--------|
    | 1         | a         | Add 'a' to set          | {'a'}           | 0      |
    | 2         | b         | Add 'b' to set          | {'a', 'b'}      | 0      |
    | 3         | c         | Add 'c' to set          | {'a', 'b', 'c'} | 0      |
    | 4         | c         | Remove 'c', result += 2 | {'a', 'b'}      | 2      |
    | 5         | c         | Add 'c' to set          | {'a', 'b', 'c'} | 2      |
    | 6         | c         | Remove 'c', result += 2 | {'a', 'b'}      | 4      |
    | 7         | d         | Add 'd' to set          | {'a', 'b', 'd'} | 4      |
    | 8         | d         | Remove 'd', result += 2 | {'a', 'b'}      | 6      |

4. **Final character_set:**
    - After processing all characters, `character_set` contains `{'a', 'b'}`.

5. **Center Character Check:**
    - Since `character_set` is not empty, we can use one of the remaining characters ('a' or 'b') as the center of the
      palindrome.
    - `result` is incremented by 1: `result = 7`

6. **Result Calculation/Return:**
    - The function returns the final `result` value of 7.
      This means the longest possible palindrome we can construct from `"abccccdd"` has a length of 7.
      One possible palindrome is `"dccaccd"`.

---

## June 5 -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

## June 6 -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

## June 7 -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

## June 8 -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

## June 9 -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```
{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---
