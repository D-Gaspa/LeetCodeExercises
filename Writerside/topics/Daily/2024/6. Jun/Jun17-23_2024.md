# June 2024, Week 4: June 17th - June 23rd

## June 17 -> 633. Sum of Square Numbers {collapsible="true" default-state="collapsed"}

Given a non-negative integer `c`, decide whether there are two integers `a` and `b` such that `a^2 + b^2 = c`.

**Example 1:**

- **Input:** c = 5
- **Output:** true
- **Explanation:** 1 * 1 + 2 * 2 = 5

**Example 2:**

- **Input:** c = 3
- **Output:** false

**Constraints:**

- `0 <= c <= 2^31 - 1`

---

### Approach 1: Two-Pointer Technique {id="approach_d1_1" collapsible="true" default-state="expanded"}

```Python
def judgeSquareSum1(c: int) -> bool:
    """
    Determines if a given non-negative integer 'c' can be expressed as
    the sum of squares of two integers 'a' and 'b'.

    The function uses a two-pointer technique starting from 0 and the
    square root of 'c'. It iteratively checks the sum of squares of
    the two pointers, 'start_index' and 'end_index'. If the sum is
    less than 'c', it increases 'start_index' to get a larger sum.
    If the sum is greater than 'c', it decreases 'end_index' to get
    a smaller sum. If the sum is equal to 'c', the function returns
    True as it has found the pair of numbers. If no such pair is found
    after the loop, it returns False. This approach works because if
    there exist two numbers 'a' and 'b' such that a^2 + b^2 = c, then
    'a' and 'b' must each be less than or equal to sqrt(c).

    The time complexity of this function is O(√c) because, in the
    worst case, the while loop iterates up to the square root of 'c' times.
    The space complexity is O(1) as it uses a constant amount of extra space.
    """
    start_index = 0
    end_index = int(math.sqrt(c))

    while start_index <= end_index:
        # a * a instead of a ** 2 because it's faster
        squares_sum = start_index * start_index + end_index * end_index
        if squares_sum < c:
            start_index += 1
        elif squares_sum > c:
            end_index -= 1
        else:
            return True
    return False
```

{collapsible="true" default-state="expanded" collapsed-title="Two-Pointer Technique Code..."}

#### Understanding the Core Idea {id="core-idea_d1_1" collapsible="true" default-state="expanded"}

The core idea of this solution is to find if the given integer `c` can be decomposed into the sum of two perfect squares
using a two-pointer approach.
Here's the breakdown of the concept:

- **Two-Pointer Approach:**
    - The function initializes two pointers: `start_index` at 0 and `end_index` at the square root of `c`.
      These pointers represent potential values of 'a' and 'b'.
    - In each iteration, it calculates the `squares_sum` of the squares of these pointers.
    - If `squares_sum` equals `c`, it means we've found a pair of integers (a, b) whose squares add up to `c`.
    - If `squares_sum` is less than `c`, we increment `start_index` to increase the sum (since a^2 is the smaller term).
    - If `squares_sum` is greater than `c`, we decrement `end_index` to decrease the sum (since b^2 is the larger term).

- **Mathematical Basis:**
    - The algorithm is based on the fact that if a number `c` can be expressed as the sum of two squares, the
      numbers `a` and `b` must each be less than or equal to the square root of `c`.
      This ensures we only check relevant values.

> **Key Insights:**
>
> **Sorted Search Space:** The potential values of `a` and `b` that we check are inherently sorted due to the nature of
> squares.
> This allows us to efficiently narrow down the search space.
>
> **Early Termination:** If we find a match, we can return `True` immediately.
> If `start_index` crosses `end_index`, there's no need to continue searching.
>
{style="note"}

---

#### Code Walkthrough {id="code-walkthrough_d1_1" collapsible="true" default-state="expanded"}

1. **Initialization:**
    - `start_index` is set to 0, representing the smallest possible square.
    - `end_index` is set to the integer part of the square root of `c`, representing the largest possible square within
      the range.

2. **Main Loop (Two-Pointer Search):**
    - The `while` loop runs as long as `start_index` is less than or equal to `end_index`.
    - In each iteration:
        - `squares_sum` is calculated as `start_index * start_index + end_index * end_index`.
        - **Decision Point (Conditional Statements):**
            - If `squares_sum == c`, the function returns `True` (pair found).
            - If `squares_sum < c`, we increase `start_index` by 1.
            - If `squares_sum > c`, we decrease `end_index` by 1.

3. **Result Calculation/Return:**
    - If the loop completes without finding a match, the function returns `False` (no pair exists).

---

#### Example {id="example_d1_1" collapsible="true" default-state="expanded"}

**Input:** `c = 98`

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - `start_index` is set to 0.
    - `end_index` is set to the integer part of the square root of 98, which is 9.

2. **Main Loop (Two-Pointer Search):**

    - **While $0 \leq 9$ (Iteration 1):**
        - `squares_sum` = $0^2 + 9^2 = 81$
        - Since 81 < 98, we increment `start_index` to 1.

    - **While $1 \leq 9$ (Iteration 2):**
        - `squares_sum` = $1^2 + 9^2 = 82$
        - Since 82 < 98, we increment `start_index` to 2.

    - **While $2 \leq 9$ (Iteration 3):**
        - `squares_sum` = $2^2 + 9^2 = 85$
        - Since 85 < 98, we increment `start_index` to 3.

    - **While $3 \leq 9$ (Iteration 4):**
        - `squares_sum` = $3^2 + 9^2 = 90$
        - Since 90 < 98, we increment `start_index` to 4.

    - **While $4 \leq 9$ (Iteration 5):**
        - `squares_sum` = $4^2 + 9^2 = 97$
        - Since 97 < 98, we increment `start_index` to 5.

    - **While $5 \leq 9$ (Iteration 6):**
        - `squares_sum` = $5^2 + 9^2 = 106$
        - Since 106 > 98, we decrement `end_index` to 8.

    - **While $5 \leq 8$ (Iteration 7):**
        - `squares_sum` = $5^2 + 8^2 = 89$
        - Since 89 < 98, we increment `start_index` to 6.

    - **While $6 \leq 8$ (Iteration 8):**
        - `squares_sum` = $6^2 + 8^2 = 100$
        - Since 100 > 98, we decrement `end_index` to 7.

    - **While $6 \leq 7$ (Iteration 9):**
        - `squares_sum` = $6^2 + 7^2 = 85$
        - Since 85 < 98, we increment `start_index` to 7.

    - **While $7 \leq 7$ (Iteration 10):**
        - `squares_sum` = $7^2 + 7^2 = 98$
        - Since 98 == 98, we have found a valid pair (7, 7), and the function returns `True`.

3. **Loop Termination:** The loop terminates when `squares_sum == c`, indicating a valid pair of integers has been
   found.

4. **Iteration Summary:**

   | `start_index` | `end_index` | `squares_sum` | Comparison | Action             |
   |---------------|-------------|---------------|------------|--------------------|
   | 0             | 9           | 81            | 81 < 98    | `start_index += 1` |
   | 1             | 9           | 82            | 82 < 98    | `start_index += 1` |
   | 2             | 9           | 85            | 85 < 98    | `start_index += 1` |
   | 3             | 9           | 90            | 90 < 98    | `start_index += 1` |
   | 4             | 9           | 97            | 97 < 98    | `start_index += 1` |
   | 5             | 9           | 106           | 106 > 98   | `end_index -= 1`   |
   | 5             | 8           | 89            | 89 < 98    | `start_index += 1` |
   | 6             | 8           | 100           | 100 > 98   | `end_index -= 1`   |
   | 6             | 7           | 85            | 85 < 98    | `start_index += 1` |
   | 7             | 7           | 98            | 98 == 98   | Return True        |

5. **Result Calculation/Final Steps:**
    - The function directly returns `True` as soon as it finds the valid pair (7, 7).
      It does not need to calculate or return any additional values.
    - The pair (7, 7) satisfies the condition $7^2 + 7^2 = 98$, confirming that 98 can be expressed as the sum of two
      squares.

---

#### Complexity Analysis {id="complexity-analysis_d1_1" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(\sqrt{c})$ where $c$ is the input integer.
  In the worst case, the `while` loop will run up to the square root of $c$ times.

**Space Complexity:**

- $O(1)$ (Constant): The algorithm uses only a fixed number of variables (`start_index`, `end_index`, `squares_sum`),
  and this number doesn't grow with the input size.

---

### Approach 2: Number Theory (Fermat's Theorem) {id="approach_d1_2" collapsible="true" default-state="expanded"}

```Python
def judgeSquareSum2(c: int) -> bool:
    """
    Determines if a given non-negative integer 'c' can be expressed as
    the sum of squares of two integers 'a' and 'b'.

    The function uses properties from number theory, particularly
    Fermat's theorem on sums of two squares. According to the theorem,
    a non-negative integer can be expressed as a sum of two squares if
    and only if every prime factor of the form (4k + 3) has an even
    exponent in the factorization of 'c'.

    The function iterates through possible prime factors up to the
    square root of 'c'. For each factor, it counts the number of times
    it divides 'c'. If a prime factor of the form (4k + 3) divides 'c'
    an odd number of times, the function returns False. Additionally,
    after factoring out all smaller primes, if the remaining part of
    'c' is a prime of the form (4k + 3), the function also returns False.
    If no such prime factors are found, the function returns True.

    The time complexity of this solution is O(√c log c) because it
    iterates up to the square root of 'c' and performs division
    operations for each prime factor (log c). The space complexity is
    O(1) as it uses a constant amount of extra space.
    """
    index = 2
    while index * index <= c:
        divisors_count = 0
        if c % index == 0:
            while c % index == 0:
                divisors_count += 1
                c //= index
            if divisors_count % 2 and index % 4 == 3:
                return False
        index += 1
    return c % 4 != 3
```

{collapsible="true" default-state="expanded" collapsed-title="Number Theory (Fermat's Theorem) Code..."}

#### Understanding the Core Idea {id="core-idea_d1_2" collapsible="true" default-state="expanded"}

The core idea of this solution is to leverage Fermat's Theorem on sums of two squares to determine if a given number
can be expressed as such.
Fermat's theorem states:

> An integer greater than one can be written as a sum of two squares if and only if its prime decomposition contains
> no prime congruent to 3 (mod 4) raised to an odd power.
>
{style="info"}

In simpler terms, a number can be expressed as the sum of two squares unless it has a prime factor of the form $4k + 3$
(such as 3, 7, 11, etc.) that appears an odd number of times in its prime factorization.

This is because a prime of the form $4k + 3$ cannot be expressed as the sum of two squares
(as opposed to primes of the form $4k + 1$ which can always be expressed as the sum of two squares).
When a prime of the form $4k + 3$ appears with an even exponent in the prime factorization of $c$,
its contribution to the overall sum of squares can be paired off and effectively neutralized.
However, if such a prime appears with an odd exponent, it cannot be paired off,
and its presence fundamentally prevents $c$ from being expressed as the sum of two squares.
This is because the square of any number is congruent to 0 or 1 (mod 4), but never 3.

Another important concept is the Brahmagupta-Fibonacci identity, which states that the product of two sums of two
squares is itself a sum of two squares.
This property allows us to combine the squares of two numbers to form a new sum of squares:

$$
(a^2 + b^2)(c^2 + d^2) = (ac - bd)^2 + (ad + bc)^2
$$

This identity is crucial in the context of Fermat's theorem and the decomposition of numbers into sums of squares.
When a prime factor $p$ of the form $4k + 3$ appears with an even exponent,
it can be paired off to form a new sum of squares: $p^{2k} = (p^k)^2 + (0)^2$, and this can be combined with other
sums of squares to form a larger sum of squares.
However, if $p$ appears with an odd exponent, it cannot be paired off.
The number cannot be expressed as a sum of squares due to the presence of the lone $p$ term
(which is congruent to 3 mod 4).

- **Prime Factorization:** The solution systematically checks for prime factors of $c$ up to its square root.
- **Counting Divisibility:** For each prime factor, it counts how many times it divides $c$ evenly (tracked
  by `divisors_count`).
- **Checking Fermat's Condition:** If a prime factor of the form $4k + 3$ has an odd `divisors_count`, the number cannot
  be a sum of squares (returns `False`).
- **Base Case:** After iterating through smaller primes, the remaining value of $c$ is either 1 or a prime.
  It checks if this remaining prime is of the form $4k + 3$.
  If it is, it returns `False`; otherwise, it returns `True`.

---

#### Code Walkthrough {id="code-walkthrough_d1_2" collapsible="true" default-state="expanded"}

1. **Initialization:**
    - `index` is initialized to 2, the smallest prime number.

2. **Main Loop (Checking Prime Factors):**
    - The `while` loop iterates as long as the square of `index` (potential prime factor) is less than or equal to `c`.
    - **Inner Loop (Counting Divisors):**
        - If `c` is divisible by `index`, a nested `while` loop repeatedly divides `c` by `index` to count its
          occurrences.
    - **Decision Points (Fermat's Condition):**
        - After the inner loop, it checks if `divisors_count` is odd (indicating an odd power) and if `index` is of the
          form `4k + 3`.
          If both are true, the function returns `False`.

3. **Base Case (After Main Loop):**
    - If the main loop completes without returning, `c` is either 1 or a prime.
    - It checks if the remaining `c` is of the form `4k + 3`. If so, it returns `False`; otherwise, `True`.

---

#### Example {id="example_d1_2" collapsible="true" default-state="expanded"}

**Input:** `c = 98`

**Step-by-Step Walkthrough:**

1. **Initialization:**
    - `index` is initialized to 2, the smallest prime number.

2. **Main Loop (Checking Prime Factors):**

    - **While $2 \times 2 = 4 \leq 98$ (Iteration 1):**
        - `index = 2`
        - `c` is divisible by `index` (98 % 2 == 0).
        - Inner loop counts the divisors: `divisors_count = 1`, `c = 49` (after division)
        - `divisors_count` is 1 and `index` (2) is not of the form 4k+3, so the loop continues.
        - `index` is incremented to 3.

    - **While $3 \times 3 = 9 \leq 49$ (Iteration 2):**
        - `index = 3`
        - `c` is not divisible by `index` (49 % 3 != 0), so the loop continues.
        - `index` is incremented to 4.

    - **While $4 \times 4 = 16 \leq 49$ (Iteration 3):**
        - `index = 4`
        - `c` is not divisible by `index` (49 % 4 != 0), so the loop continues.
        - `index` is incremented to 5.

    - **While $5 \times 5 = 25 \leq 49$ (Iteration 4):**
        - `index = 5`
        - `c` is not divisible by `index` (49 % 5 != 0), so the loop continues.
        - `index` is incremented to 6.

    - **While $6 \times 6 = 36 \leq 49$ (Iteration 5):**
        - `index = 6`
        - `c` is not divisible by `index` (49 % 6 != 0), so the loop continues.
        - `index` is incremented to 7.

    - **While $7 \times 7 = 49 \leq 49$ (Iteration 6):**
        - `index = 7`
        - `c` is divisible by `index` (49 % 7 == 0).
        - Inner loop counts the divisors:
            - `divisors_count = 1`, `c = 7`
            - `divisors_count = 2`, `c = 1`
        - `index` (7) is of the form 4k+3, but since `divisors_count` is even (2), the loop continues.
        - `index` is incremented to 8.

3. **Loop Termination:** The loop terminates after iteration 6 because `index * index` (64) is not less than or equal to
   the current value of `c` (1).

4. **Iteration Summary/Visual Aids:**

   | `c` | `index` | `divisors_count` | `index % 4 == 3` | Result                   |
   |-----|---------|------------------|------------------|--------------------------|
   | 108 | 2       | 1                | False            | Continue                 |
   | 49  | 3       | 0                | False            | Continue                 |
   | 49  | 4       | 0                | False            | Continue                 |
   | 49  | 5       | 0                | False            | Continue                 |
   | 49  | 6       | 0                | False            | Continue                 |
   | 49  | 7       | 2                | True             | Continue (Even exponent) |

5. **Result Calculation/Final Steps:**
    - After the loop, `c` is 1. Since 1 is not of the form 4k + 3, the function returns `True`, indicating that 98 can
      be expressed as the sum of two squares $(7^2 + 7^2 = 98)$.

6. **Visualizing the Pairing of Squares:**
    - Since the factorization of 98 is $2 \cdot 7^2$, the prime factor 7 (of the form $4k + 3$) appears with an even
      exponent (2), allowing it to be paired off and expressed as a sum of squares.
    - This can be visualized using the Brahmagupta-Fibonacci identity to combine the squares of 7 into a new sum of
      squares:
        - We know that $2 = 1^2 + 1^2$, and we can express $7^2$ as $7^2 + 0^2$.
          With the factorization, we get the product of these two sums of squares:
            - $(1^2 + 1^2) \cdot (7^2 + 0^2) = 98$.
        - Using the identity, we can combine these to get $(1 \cdot 7 - 1 \cdot 0)^2 + (1 \cdot 0 + 1 \cdot 7)^2 = 7^2 +
          7^2 = 98$.

---

#### Complexity Analysis {id="complexity-analysis_d1_2" collapsible="true" default-state="expanded"}

**Time Complexity:**

- $O(\sqrt{c} \log c)$.
  The main loop runs up to $\sqrt{c}$ times.
  For each iteration, the inner loop might run up to $\log c$ times in the worst case
  (for a prime that divides `c` many times).

**Space Complexity:**

- $O(1)$ (Constant): The algorithm uses a fixed number of variables (`index`, `divisors_count`, `c`), regardless of the
  input size.

---

## June X -> 2. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d2_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d2_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d2_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d2_2" collapsible="true" default-state="expanded"}

...

---

## June X -> 3. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d3_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d3_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d3_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d3_2" collapsible="true" default-state="expanded"}

...

---

## June X -> 4. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d4_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d4_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d4_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d4_2" collapsible="true" default-state="expanded"}

...

---

## June X -> 5. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d5_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d5_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d5_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d5_2" collapsible="true" default-state="expanded"}

...

---

## June X -> 6. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d6_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d6_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d6_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d6_2" collapsible="true" default-state="expanded"}

...

---

## June X -> 7. Problem Name {collapsible="true" default-state="collapsed"}

[Problem Statement]

---

### Approach 1: Approach Name {id="approach_d7_1" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_1" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_1" collapsible="true" default-state="expanded"}

...

---

### Approach 2: Approach Name {id="approach_d7_2" collapsible="true" default-state="expanded"}

```Python
# Code
```

{collapsible="true" default-state="expanded" collapsed-title="Approach Name Code..."}

#### Understanding the Core Idea {id="core-idea_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Code Walkthrough {id="code-walkthrough_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Example {id="example_d7_2" collapsible="true" default-state="expanded"}

...

---

#### Complexity Analysis {id="complexity-analysis_d7_2" collapsible="true" default-state="expanded"}

...

---
